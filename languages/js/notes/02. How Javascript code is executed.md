# How JavaScript Code is Executed
f
## Table of Contents
- [Introduction](#introduction)
- [Compilation Phase](#1-compilation-phase)
  - [Steps in the Compilation Phase](#steps-in-the-compilation-phase)
  - [Visual Representation of Compilation Phase](#visual-representation-of-compilation-phase)
- [Execution Phase](#2-execution-phase)
  - [Steps in the Execution Phase](#steps-in-the-execution-phase)
  - [Visual Representation of Execution Phase](#visual-representation-of-execution-phase)
- [Key Components](#key-components)
- [JavaScript Execution Context](#javascript-execution-context)
- [Execution Process Example](#execution-process-example)
  - [Creation Phase](#phase-1-creation-phase-memory-creationallocation-phase)
  - [Execution Phase](#phase-2-execution-phase-code-execution-phase)
  - [Final Memory State](#final-memory-state-after-execution)

## Introduction

JavaScript code execution involves two main phases: **Compilation** and **Execution**. This process is handled by the JavaScript Engine (e.g., V8 for Chrome and Node.js).

For a detailed explanation, refer to this [video tutorial](https://www.youtube.com/watch?v=ZvbzSrg0afE&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=3).

---

## 1. **Compilation Phase**
- The JavaScript engine parses the code and creates a **Memory Heap** and a **Call Stack**.
- Variables and functions are stored in memory during this phase (hoisting occurs here).
- Other Names of **Call Stack** are - 
    - Execution Context Stack
    - Program Stack
    - Control Stack
    - Runtime Stack
    - Machine Stack

### Steps in the Compilation Phase:

1. **Lexical Analysis (Tokenizing)**:
    - The JavaScript engine scans the source code and breaks it into meaningful sequences of characters called tokens.
    - Tokens include keywords, identifiers, literals, operators, and punctuation.

2. **Syntax Analysis (Parsing)**:
    - The engine takes the tokens and organizes them into a hierarchical structure called an Abstract Syntax Tree (AST).
    - The AST represents the logical structure of the code, making it easier for the engine to analyze and process.

3. **Semantic Analysis**:
    - The engine checks the AST for semantic errors, such as type mismatches or invalid operations.
    - This ensures that the code adheres to the language's rules and specifications.

4. **Intermediate Code Generation**:
    - The AST is converted into an intermediate representation (IR), which is a lower-level, platform-independent code.
    - This step bridges the gap between the high-level JavaScript code and the machine-level code.

5. **Optimization**:
    - The intermediate code is optimized for better performance.
    - Common optimizations include removing redundant operations, inlining functions, and simplifying expressions.

6. **Machine Code Generation**:
    - The optimized intermediate code is translated into machine code or bytecode that the JavaScript engine can execute.
    - This machine code is specific to the underlying hardware and operating system.

7. **Memory Allocation**:
    - The engine allocates memory for variables, functions, and objects.
    - During this step, variable and function declarations are hoisted to the top of their respective scopes.

8. **Scope and Context Creation**:
    - The engine establishes the scope chain and execution context for the code.
    - This determines the accessibility of variables and functions during execution.

9. **Error Handling Preparation**:
    - The engine sets up mechanisms to handle runtime errors, such as syntax errors or type errors, that may occur during execution.

10. **Ready for Execution**:
    - Once the compilation phase is complete, the engine transitions to the execution phase, where the code is executed line by line.

1. **Tokenizing/Lexical Analysis**:
    - The JavaScript engine breaks the code into smaller chunks called tokens.
    - Tokens are meaningful sequences of characters, such as keywords, variable names, operators, etc.

2. **Parsing**:
    - The tokens are analyzed and converted into an Abstract Syntax Tree (AST).
    - The AST represents the structure of the code in a tree format, making it easier for the engine to understand.

3. **Code Generation**:
    - The AST is used to generate machine code or bytecode that the JavaScript engine can execute.

4. **Memory Allocation**:
    - Variables and function declarations are stored in memory.
    - This is where **hoisting** occurs, meaning variable and function declarations are moved to the top of their scope.

5. **Scope Creation**:
    - The engine creates a scope for the code, determining the accessibility of variables and functions.
    - Global and local scopes are established during this phase.


### Visual Representation of Compilation Phase:
```
┌───────────────────────────────────────────┐
│             Compilation Phase             │
│                                           │
│  ┌────────────────┐   ┌────────────────┐  │
│  │ Tokenizing &   │   │ Memory         │  │
│  │ Parsing (AST)  │ → │ Allocation     │  │
│  │                │   │ (Hoisting)     │  │
│  └────────────────┘   └────────────────┘  │
│                                           │
│  ┌───────────────┐   ┌─────────────────┐  │
│  │ Semantic      │   │ Code            │  │
│  │ Analysis      │ → │ Optimization    │  │
│  │               │   │ & Machine Code  │  │
│  │               │   │ Generation      │  │
│  └───────────────┘   └─────────────────┘  │
└───────────────────────────────────────────┘
```

---

## 2. **Execution Phase**
- The code is executed line by line in the **Call Stack**.
- Functions are pushed to and popped from the stack as they are invoked.

### Steps in the Execution Phase:
1. **Global Execution Context Creation**:
    - The JavaScript engine creates a global execution context.
    - This context includes the global memory and the global code execution thread.

2. **Code Execution Begins**:
    - The engine starts executing the code line by line.
    - Variables are assigned values, and functions are invoked.

3. **Function Invocation**:
    - When a function is called, a new execution context is created for that function.
    - This context includes its own memory space and code execution thread.

4. **Call Stack Management**:
    - The execution context of the function is pushed onto the Call Stack.
    - Once the function execution is complete, its context is popped off the stack.

5. **Handling Asynchronous Code**:
    - Asynchronous operations (e.g., setTimeout, Promises) are sent to the Web APIs or Node.js APIs.
    - Once completed, their callbacks are queued in the Callback Queue or Microtask Queue.

6. **Event Loop**:
    - The Event Loop continuously checks if the Call Stack is empty.
    - If the stack is empty, it pushes tasks from the Callback Queue or Microtask Queue to the Call Stack for execution.

7. **Execution Completion**:
    - The process continues until all synchronous and asynchronous code is executed.
    - The global execution context is removed from the Call Stack once the program finishes.

---

### Visual Representation of Execution Phase:
```
┌──────────────────────────────────────────────┐
│               Execution Phase                │
│                                              │
│  ┌────────────────┐   ┌───────────────────┐  │
│  │   Call Stack   │ ↔ │   Memory Heap     │  │
│  │                │   │                   │  │
│  │  Tracks the    │   │  Stores variables │  │
│  │  order of      │   │  and functions    │  │
│  │  function      │   │                   │  │
│  │  execution     │   │                   │  │
│  └────────────────┘   └───────────────────┘  │
│                                              │
│  ┌───────────────────────────────────────┐   │
│  │               Event Loop              │   │
│  │  Monitors the Call Stack and moves    │   │
│  │  tasks from the Callback/Microtask    │   │
│  │  Queue to the Call Stack when empty   │   │
│  └───────────────────────────────────────┘   │
│                                              │
│  ┌───────────────────────────────────────┐   │
│  │           Callback Queue              │   │
│  │  Holds asynchronous tasks (e.g.,      │   │
│  │  setTimeout, Promises) until they     │   │
│  │  are ready to be executed             │   │
│  └───────────────────────────────────────┘   │
└──────────────────────────────────────────────┘
```

---

## Key Components:
1. **Memory Heap**: Stores variables and function declarations.
2. **Call Stack**: Tracks function calls and their execution order.
3. **Event Loop**: Handles asynchronous operations by checking the **Callback Queue** and pushing tasks to the Call Stack when it's empty.

---

## Visual Representation

### JavaScript Execution Context

When JavaScript code is executed, an **Execution Context** is created, which consists of two components:

1. **Memory Component** (Variable Environment)
    - Stores variables and functions as key-value pairs
    - Also known as the "Variable Environment"

2. **Code Component** (Thread of Execution)
    - Place where code is executed line by line
    - Also known as the "Thread of Execution"

#### Visual Representation:
```
┌─────────────────────────────┐
│     Execution Context       │
│                             │
│  ┌───────────┐ ┌─────────┐  │
│  │  Memory   │ │  Code   │  │
│  │Component  │ │Component│  │
│  └───────────┘ └─────────┘  │
└─────────────────────────────┘
```

---

### Execution Process Example

```javascript
var n = 2;
function square(num) {
     var ans = num * num;
     return ans;
}
var square2 = square(n);
var square4 = square(4);
```

#### Phase 1: Creation Phase (Memory Creation/Allocation Phase)

1. **Global Memory Setup**:
    - The JavaScript engine scans the code and allocates memory for variables and functions.
    - Variables are initialized with `undefined`, and functions are stored as references.

2. **Memory Component After Creation**:
    - The memory component looks like this:
      ```
      Memory Component:
      ┌───────────────────────┐
      │ n: undefined          │
      │ square: function {...}│
      │ square2: undefined    │
      │ square4: undefined    │
      └───────────────────────┘
      ```

---

#### Phase 2: Execution Phase (Code Execution Phase)

1. **Code Execution Begins**:
    - The JavaScript engine starts executing the code line by line in the **Call Stack**.

2. **Line 1: `var n = 2;`**:
    - The value `2` is assigned to the variable `n` in the memory component.
    - Updated memory component:
      ```
      Memory Component:
      ┌────────────────────────┐
      │ n: 2                   │
      │ square: function {...} │
      │ square2: undefined     │
      │ square4: undefined     │
      └────────────────────────┘
      ```
    - Code Component:
      ```
      Code Component:
      ┌──────────────────────────┐
      │ var n = 2;               │ ← Currently executing
      │ function square(num){}   │
      │ var square2 = square(n); │
      │ var square4 = square(4); │
      └──────────────────────────┘
      ```
    - Call Stack:
      ```
      Call Stack:
      ┌───────────────────────┐
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```

3. **Line 2: `function square(num) {...}`**:
    - The function `square` is already stored in memory during the creation phase, so no changes occur here.
    - Code Component:
      ```
      Code Component:
      ┌──────────────────────────┐
      │ var n = 2;               │ ✓ Executed
      │ function square(num){}   │ ← Currently executing
      │ var square2 = square(n); │
      │ var square4 = square(4); │
      └──────────────────────────┘
      ```
    - Call Stack:
      ```
      Call Stack:
      ┌───────────────────────┐
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```

4. **Line 3: `var square2 = square(n);`**:
    - A new execution context is created for the function `square(n)`.
    - Code Component (Global):
      ```
      Code Component (Global):
      ┌──────────────────────────┐
      │ var n = 2;               │ ✓ Executed
      │ function square(num){}   │ ✓ Executed
      │ var square2 = square(n); │ ← Currently executing
      │ var square4 = square(4); │
      └──────────────────────────┘
      ```
    - Call Stack:
      ```
      Call Stack:
      ┌───────────────────────┐
      │ square(n)             │
      ├───────────────────────┤
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```
      
    - **Memory Component for `square(n)`**:
      ```
      Memory Component:
      ┌─────────────────────┐
      │ num: 2              │
      │ ans: undefined      │
      └─────────────────────┘
      ```
    - **Code Component for `square(n)`**:
      ```
      Code Component:
      ┌──────────────────────┐
      │ var ans = num * num; │
      │ return ans;          │
      └──────────────────────┘
      ```
      
    - **Code Execution in `square(n)`**:
      - `ans = num * num;` → `ans = 2 * 2;` → `ans = 4`.
      - `return ans;` → The value `4` is returned to the global execution context.
      - After returning the value, this execution context will be popped from the call stack.
      
    - **Global Memory Component After Execution**:
      ```
      Memory Component:
      ┌────────────────────────┐
      │ n: 2                   │
      │ square: function {...} │
      │ square2: 4             │
      │ square4: undefined     │
      └────────────────────────┘
      ```
    
    - Call Stack (after returning):
      ```
      Call Stack:
      ┌───────────────────────┐
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```

5. **Line 4: `var square4 = square(4);`**:
    - A new execution context is created for the function `square(4)`.
    - Code Component (Global):
      ```
      Code Component (Global):
      ┌──────────────────────────┐
      │ var n = 2;               │ ✓ Executed
      │ function square(num){}   │ ✓ Executed
      │ var square2 = square(n); │ ✓ Executed
      │ var square4 = square(4); │ ← Currently executing
      └──────────────────────────┘
      ```
    
    - Call Stack:
      ```
      Call Stack:
      ┌───────────────────────┐
      │ square(4)             │
      ├───────────────────────┤
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```
      
    - **Memory Component for `square(4)`**:
      ```
      Memory Component:
      ┌────────────────────┐
      │ num: 4             │
      │ ans: undefined     │
      └────────────────────┘
      ```
    - **Code Component for `square(4)`**:
      ```
      Code Component:
      ┌──────────────────────┐
      │ var ans = num * num; │
      │ return ans;          │
      └──────────────────────┘
      ```
      
    - **Code Execution in `square(4)`**:
      - `ans = num * num;` → `ans = 4 * 4;` → `ans = 16`.
      - `return ans;` → The value `16` is returned to the global execution context.
      - After returning the value, this execution context will be popped from the call stack.

    - **Global Memory Component After Execution**:
      ```
      Memory Component:
      ┌────────────────────────┐
      │ n: 2                   │
      │ square: function {...} │
      │ square2: 4             │
      │ square4: 16            │
      └────────────────────────┘
      ```
    
    - Call Stack (after returning):
      ```
      Call Stack:
      ┌───────────────────────┐
      │ Global Execution      │
      │ Context               │
      └───────────────────────┘
      ```

---

#### Final Memory State After Execution

```
Memory Component:
┌────────────────────────┐
│ n: 2                   │
│ square: function {...} │
│ square2: 4             │
│ square4: 16            │
└────────────────────────┘
```

```
Call Stack:
┌───────────────────────┐
│ Global Execution      │
│ Context               │
└───────────────────────┘
```

---
=> This step-by-step breakdown illustrates how the JavaScript engine handles memory allocation and execution for the given code.