# Function Pointers

## What are Function Pointers?

Function pointers are variables that store the address of a function in memory. They allow you to treat functions as data, enabling dynamic function calls at runtime.

```cpp
// Basic syntax
return_type (*pointer_name)(parameter_types);

// Example
int (*funcPtr)(int, int);
```

## How to Use Function Pointers

### Declaration and Assignment
```cpp
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

// Declare and assign
int (*operation)(int, int) = add;
int result = operation(5, 3); // Calls add(5, 3)

// Reassign
operation = multiply;
result = operation(5, 3); // Calls multiply(5, 3)
```

### Function Pointer Arrays
```cpp
int (*operations[])(int, int) = {add, multiply, subtract};
int result = operations[0](10, 5); // Calls add
```

## When to Use Function Pointers

- **Callback functions**: Pass functions as arguments to other functions
- **Event handling**: Register functions to handle specific events
- **Strategy pattern**: Switch between different algorithms at runtime
- **Plugin systems**: Load and call functions dynamically
- **State machines**: Execute different functions based on current state

## Benefits and Reusability

### Code Flexibility
```cpp
void processArray(int arr[], int size, int (*func)(int)) {
    for (int i = 0; i < size; i++) {
        arr[i] = func(arr[i]);
    }
}

int square(int x) { return x * x; }
int cube(int x) { return x * x * x; }

// Reusable with different functions
processArray(data, 10, square);
processArray(data, 10, cube);
```

### Polymorphism Alternative
Function pointers provide a C-style alternative to virtual functions, enabling runtime polymorphism without classes.

### Performance
Direct function calls through pointers can be more efficient than virtual function calls in some scenarios.

## Best Practices

- Use `typedef` or `using` for complex function pointer types
- Initialize function pointers to avoid undefined behavior
- Consider `std::function` in C++ for more flexibility
- Document the expected function signature clearly

```cpp
// Type alias for cleaner code
using MathOperation = int(*)(int, int);
MathOperation op = add;
```

## Complete Example

Here's a comprehensive example demonstrating various function pointer concepts:

```cpp
#include <iostream>
using namespace std;

// Regular functions that will be pointed to
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

// Function that takes another function as parameter
int calculate(int x, int y, int (*operation)(int, int)) {
    return operation(x, y);
}

// Function that returns a function pointer
int (*getOperation(char op))(int, int) {
    switch(op) {
        case '+': return add;
        case '-': return subtract;
        case '*': return multiply;
        default: return nullptr;
    }
}

int main() {
    // Basic function pointer declaration and usage
    int (*funcPtr)(int, int);
    
    cout << "=== Basic Function Pointer Usage ===" << endl;
    funcPtr = add;
    cout << "5 + 3 = " << funcPtr(5, 3) << endl;
    
    funcPtr = subtract;
    cout << "5 - 3 = " << funcPtr(5, 3) << endl;
    
    funcPtr = multiply;
    cout << "5 * 3 = " << funcPtr(5, 3) << endl;
    
    // Array of function pointers for reusability
    cout << "\n=== Array of Function Pointers ===" << endl;
    int (*operations[])(int, int) = {add, subtract, multiply};
    string opNames[] = {"Addition", "Subtraction", "Multiplication"};
    
    for(int i = 0; i < 3; i++) {
        cout << opNames[i] << ": 8, 4 = " << operations[i](8, 4) << endl;
    }
    
    // Using function pointer as parameter
    cout << "\n=== Function Pointer as Parameter ===" << endl;
    cout << "Calculate (10, 5) with add: " << calculate(10, 5, add) << endl;
    cout << "Calculate (10, 5) with subtract: " << calculate(10, 5, subtract) << endl;
    cout << "Calculate (10, 5) with multiply: " << calculate(10, 5, multiply) << endl;
    
    // Function returning function pointer
    cout << "\n=== Function Returning Function Pointer ===" << endl;
    auto op = getOperation('+');
    if(op) cout << "Dynamic operation (+): 7 + 2 = " << op(7, 2) << endl;
    
    op = getOperation('*');
    if(op) cout << "Dynamic operation (*): 7 * 2 = " << op(7, 2) << endl;
    
    return 0;
}
```

### Using Type Aliases for Cleaner Code

The same example can be improved using type aliases:

```cpp
#include <iostream>
using namespace std;

// Type alias for function pointer
using MathOperation = int(*)(int, int);

// Regular functions that will be pointed to
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

// Cleaner function parameter
int calculate(int x, int y, MathOperation operation) {
    return operation(x, y);
}

// Cleaner return type
MathOperation getOperation(char op) {
    switch(op) {
        case '+': return add;
        case '-': return subtract;
        case '*': return multiply;
        default: return nullptr;
    }
}

int main() {
    // Cleaner declaration using type alias
    MathOperation funcPtr;
    
    cout << "=== Basic Function Pointer Usage (with alias) ===" << endl;
    funcPtr = add;
    cout << "5 + 3 = " << funcPtr(5, 3) << endl;
    
    funcPtr = subtract;
    cout << "5 - 3 = " << funcPtr(5, 3) << endl;
    
    funcPtr = multiply;
    cout << "5 * 3 = " << funcPtr(5, 3) << endl;
    
    // Cleaner array declaration
    MathOperation operations[] = {add, subtract, multiply};
    string opNames[] = {"Addition", "Subtraction", "Multiplication"};
    
    cout << "\n=== Array of Function Pointers (with alias) ===" << endl;
    for(int i = 0; i < 3; i++) {
        cout << opNames[i] << ": 8, 4 = " << operations[i](8, 4) << endl;
    }
    
    // Using cleaner function parameter
    cout << "\n=== Function Pointer as Parameter (with alias) ===" << endl;
    cout << "Calculate (10, 5) with add: " << calculate(10, 5, add) << endl;
    cout << "Calculate (10, 5) with subtract: " << calculate(10, 5, subtract) << endl;
    cout << "Calculate (10, 5) with multiply: " << calculate(10, 5, multiply) << endl;
    
    // Using cleaner return type
    cout << "\n=== Function Returning Function Pointer (with alias) ===" << endl;
    MathOperation op = getOperation('+');
    if(op) cout << "Dynamic operation (+): 7 + 2 = " << op(7, 2) << endl;
    
    op = getOperation('*');
    if(op) cout << "Dynamic operation (*): 7 * 2 = " << op(7, 2) << endl;
    
    return 0;
}
```

The type alias approach makes the code more readable and maintainable by:
- Simplifying complex function pointer syntax
- Making function signatures more intuitive
- Reducing the chance of syntax errors
- Improving code documentation and understanding


## Method Pointers (Member Function Pointers)

Method pointers allow you to store and call member functions of classes. They are more complex than regular function pointers due to the need for an object instance.

### Basic Syntax
```cpp
// Syntax for method pointers
return_type (ClassName::*pointer_name)(parameter_types);

// Example
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    int multiply(int a, int b) { return a * b; }
};

int (Calculator::*methodPtr)(int, int) = &Calculator::add;
```

### Using Method Pointers
```cpp
#include <iostream>
using namespace std;

class MathProcessor {
public:
    int add(int a, int b) {
        cout << "Adding: ";
        return a + b;
    }
    
    int subtract(int a, int b) {
        cout << "Subtracting: ";
        return a - b;
    }
    
    int multiply(int a, int b) {
        cout << "Multiplying: ";
        return a * b;
    }
    
    void processNumbers(int x, int y, int (MathProcessor::*operation)(int, int)) {
        int result = (this->*operation)(x, y);
        cout << x << " and " << y << " = " << result << endl;
    }
};

int main() {
    MathProcessor processor;
    
    // Method pointer declaration and assignment
    int (MathProcessor::*methodPtr)(int, int) = &MathProcessor::add;
    
    // Calling through method pointer (syntax 1)
    cout << "Result: " << (processor.*methodPtr)(10, 5) << endl;
    
    // Calling through method pointer (syntax 2 - with pointer to object)
    MathProcessor* procPtr = &processor;
    cout << "Result: " << (procPtr->*methodPtr)(8, 3) << endl;
    
    // Array of method pointers
    int (MathProcessor::*operations[])(int, int) = {
        &MathProcessor::add,
        &MathProcessor::subtract,
        &MathProcessor::multiply
    };
    
    cout << "\n=== Array of Method Pointers ===" << endl;
    for(int i = 0; i < 3; i++) {
        cout << "Operation " << i << ": " << (processor.*operations[i])(6, 2) << endl;
    }
    
    // Method pointer as parameter
    cout << "\n=== Method Pointer as Parameter ===" << endl;
    processor.processNumbers(15, 4, &MathProcessor::multiply);
    processor.processNumbers(15, 4, &MathProcessor::subtract);
    
    return 0;
}
```

### Type Aliases for Method Pointers

```cpp
class Calculator {
public:
    double add(double a, double b) { return a + b; }
    double divide(double a, double b) { return b != 0 ? a / b : 0; }
    double power(double base, double exp) { return pow(base, exp); }
};

// Type alias for cleaner code
using CalcMethod = double (Calculator::*)(double, double);

void executeOperation(Calculator& calc, double x, double y, CalcMethod method) {
    double result = (calc.*method)(x, y);
    cout << "Result: " << result << endl;
}

int main() {
    Calculator calc;
    
    // Using type alias for method addresses
    constexpr CalcMethod addMethod = &Calculator::add;
    constexpr CalcMethod divideMethod = &Calculator::divide;
    constexpr CalcMethod powerMethod = &Calculator::power;
    
    // Cleaner declaration and usage
    CalcMethod operation = addMethod;
    cout << (calc.*operation)(5.5, 2.3) << endl;
    
    // Array using type alias
    CalcMethod methods[] = {addMethod, divideMethod, powerMethod};
    for(auto method : methods) {
        cout << (calc.*method)(8.0, 2.0) << endl;
    }
    
    // Using with function parameter
    executeOperation(calc, 10.0, 3.0, divideMethod);
    executeOperation(calc, 2.0, 8.0, powerMethod);
    
    return 0;
}
```

### Key Differences from Regular Function Pointers

1. **Syntax**: Method pointers require `ClassName::*` syntax
2. **Invocation**: Must use `.*` or `->*` operators with an object instance
3. **Address**: Use `&ClassName::methodName` to get the address
4. **Object requirement**: Always need an object instance to call the method

