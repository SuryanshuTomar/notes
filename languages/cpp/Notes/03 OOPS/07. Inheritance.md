# Inheritance in C++

Inheritance is a key concept in Object-Oriented Programming (OOP) that allows one class (the derived or child class) to acquire the properties and behaviors (data members and member functions) of another class (the base or parent class).

## Why is Inheritance Useful?

- **Code Reusability:** Common code can be written in the base class and reused in derived classes.
- **Extensibility:** New features can be added to existing code without modifying it.
- **Maintainability:** Changes in the base class automatically reflect in derived classes.
- **Polymorphism:** Enables dynamic method binding and flexible code.

## When Should Inheritance Be Used?

- When multiple classes share common functionality.
- When you want to model an "is-a" relationship (e.g., a `Car` is a `Vehicle`).
- When you want to extend or specialize the behavior of an existing class.

## Types of Inheritance in C++

### 1. Single Inheritance

A derived class inherits from only one base class.

**Visual Representation:**
```
    Animal
      |
     Dog
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { 
        cout << "Animal is eating\n"; 
    }
    void sleep() { 
        cout << "Animal is sleeping\n"; 
    }
};

class Dog : public Animal {
public:
    void bark() { 
        cout << "Dog is barking\n"; 
    }
};

int main() {
    Dog myDog;
    myDog.eat();    // Inherited from Animal
    myDog.sleep();  // Inherited from Animal
    myDog.bark();   // Dog's own method
    return 0;
}
```

### 2. Multiple Inheritance

A derived class inherits from more than one base class.

**Visual Representation:**
```
   Engine    Wheels
      \       /
       \     /
        Car
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class Engine {
public:
    void start() { 
        cout << "Engine started\n"; 
    }
    void stop() { 
        cout << "Engine stopped\n"; 
    }
};

class Wheels {
public:
    void rotate() { 
        cout << "Wheels rotating\n"; 
    }
    void brake() { 
        cout << "Wheels stopped\n"; 
    }
};

class Car : public Engine, public Wheels {
public:
    void drive() {
        cout << "Car is driving\n";
    }
};

int main() {
    Car myCar;
    myCar.start();   // From Engine
    myCar.rotate();  // From Wheels
    myCar.drive();   // Car's own method
    myCar.brake();   // From Wheels
    myCar.stop();    // From Engine
    return 0;
}
```

### 3. Multilevel Inheritance

A class is derived from another derived class, forming a chain.

**Visual Representation:**
```
   Animal
     |
   Mammal
     |
    Dog
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { 
        cout << "Animal eats food\n"; 
    }
};

class Mammal : public Animal {
public:
    void breathe() { 
        cout << "Mammal breathes air\n"; 
    }
    void giveMilk() { 
        cout << "Mammal produces milk\n"; 
    }
};

class Dog : public Mammal {
public:
    void bark() { 
        cout << "Dog barks\n"; 
    }
    void wagTail() { 
        cout << "Dog wags tail\n"; 
    }
};

int main() {
    Dog myDog;
    myDog.eat();      // From Animal
    myDog.breathe();  // From Mammal
    myDog.giveMilk(); // From Mammal
    myDog.bark();     // Dog's own method
    myDog.wagTail();  // Dog's own method
    return 0;
}
```

### 4. Hierarchical Inheritance

Multiple classes inherit from a single base class.

**Visual Representation:**
```
      Animal
    /   |   \
   Dog Cat  Bird
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { 
        cout << "Animal is eating\n"; 
    }
    void sleep() { 
        cout << "Animal is sleeping\n"; 
    }
};

class Dog : public Animal {
public:
    void bark() { 
        cout << "Dog barks: Woof!\n"; 
    }
};

class Cat : public Animal {
public:
    void meow() { 
        cout << "Cat meows: Meow!\n"; 
    }
};

class Bird : public Animal {
public:
    void fly() { 
        cout << "Bird flies in the sky\n"; 
    }
};

int main() {
    Dog myDog;
    Cat myCat;
    Bird myBird;
    
    myDog.eat();   // Inherited
    myDog.bark();  // Dog's method
    
    myCat.sleep(); // Inherited
    myCat.meow();  // Cat's method
    
    myBird.eat();  // Inherited
    myBird.fly();  // Bird's method
    
    return 0;
}
```

### 5. Multipath Inheritance

When a class inherits from multiple classes that have a common base class, creating multiple paths to the same base class.

**Visual Representation:**
```
      Animal
     /      \
   Mammal   Bird
     \      /
      Bat
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { 
        cout << "Animal eats\n"; 
    }
};

class Mammal : public Animal {
public:
    void giveMilk() { 
        cout << "Gives milk\n"; 
    }
};

class Bird : public Animal {
public:
    void layEggs() { 
        cout << "Lays eggs\n"; 
    }
};

// This creates ambiguity - Bat has two copies of Animal
class Bat : public Mammal, public Bird {
public:
    void fly() { 
        cout << "Bat flies\n"; 
    }
};

int main() {
    Bat myBat;
    // myBat.eat();      // Error: ambiguous call
    myBat.Mammal::eat(); // Specify which path
    myBat.Bird::eat();   // Specify which path
    myBat.giveMilk();
    myBat.layEggs();
    myBat.fly();
    return 0;
}
```

### 6. Hybrid Inheritance

Combination of two or more types of inheritance.

**Visual Representation:**
```
        A
       / \
      B   C
       \ /
        D
```

**Complete Example:**
```cpp
#include <iostream>
using namespace std;

class A {
public:
    void showA() { 
        cout << "Class A method\n"; 
    }
};

class B : public A {
public:
    void showB() { 
        cout << "Class B method\n"; 
    }
};

class C : public A {
public:
    void showC() { 
        cout << "Class C method\n"; 
    }
};

// Hybrid: combines hierarchical + multiple inheritance
class D : public B, public C {
public:
    void showD() { 
        cout << "Class D method\n"; 
    }
};

int main() {
    D obj;
    // obj.showA();    // Error: ambiguous
    obj.B::showA();    // Specify path through B
    obj.C::showA();    // Specify path through C
    obj.showB();
    obj.showC();
    obj.showD();
    return 0;
}
```

## Understanding the Diamond Problem

### What is the Diamond Problem?

The Diamond Problem occurs in multipath and hybrid inheritance when a derived class has multiple paths to the same base class. This creates:

1. **Memory Wastage:** Multiple copies of the same base class are created
2. **Ambiguity:** Compiler doesn't know which copy to use when calling base class methods
3. **Inconsistency:** Changes to one copy don't reflect in others

### Why Does It Happen?

**Memory Layout without Virtual Inheritance:**
```
Bat object contains:
├── Mammal part
│   └── Animal part (copy 1)
└── Bird part
    └── Animal part (copy 2)
```

### Real-World Example of the Problem

```cpp
#include <iostream>
using namespace std;

class Animal {
protected:
    int age = 0;
public:
    void setAge(int a) { age = a; }
    int getAge() { return age; }
    void eat() { cout << "Animal eats\n"; }
};

class Mammal : public Animal {
public:
    void giveMilk() { cout << "Gives milk\n"; }
};

class Bird : public Animal {
public:
    void layEggs() { cout << "Lays eggs\n"; }
};

class Bat : public Mammal, public Bird {
public:
    void fly() { cout << "Bat flies\n"; }
};

int main() {
    Bat myBat;
    
    // Problem 1: Ambiguous method calls
    // myBat.eat();        // ERROR: Ambiguous
    // myBat.setAge(5);    // ERROR: Ambiguous
    
    // Must specify which path to use
    myBat.Mammal::setAge(5);  // Set age through Mammal path
    myBat.Bird::setAge(3);    // Set age through Bird path
    
    cout << "Age through Mammal: " << myBat.Mammal::getAge() << endl; // Output: 5
    cout << "Age through Bird: " << myBat.Bird::getAge() << endl;     // Output: 3
    
    // Problem: Two different ages for the same bat!
    return 0;
}
```

## Virtual Inheritance - The Solution

### What is Virtual Inheritance?

Virtual inheritance ensures that only **one copy** of the base class exists in the derived class, regardless of how many paths lead to it.

### Syntax:
```cpp
class DerivedClass : virtual public BaseClass {
    // class body
};
```

### How Virtual Inheritance Works

**Memory Layout with Virtual Inheritance:**
```
Bat object contains:
├── Mammal part (no Animal)
├── Bird part (no Animal)
└── Shared Animal part (single copy)
```

### Complete Solution Example

```cpp
#include <iostream>
using namespace std;

class Animal {
protected:
    int age = 0;
    string name;
public:
    Animal() { 
        cout << "Animal constructor called\n"; 
    }
    
    void setAge(int a) { 
        age = a; 
        cout << "Age set to " << age << endl;
    }
    
    int getAge() { return age; }
    
    void setName(string n) { 
        name = n; 
        cout << "Name set to " << name << endl;
    }
    
    string getName() { return name; }
    
    void eat() { 
        cout << name << " (age " << age << ") is eating\n"; 
    }
};

// Virtual inheritance - only one Animal will exist
class Mammal : virtual public Animal {
public:
    Mammal() { 
        cout << "Mammal constructor called\n"; 
    }
    
    void giveMilk() { 
        cout << name << " gives milk\n"; 
    }
};

// Virtual inheritance - shares the same Animal
class Bird : virtual public Animal {
public:
    Bird() { 
        cout << "Bird constructor called\n"; 
    }
    
    void layEggs() { 
        cout << name << " lays eggs\n"; 
    }
};

class Bat : public Mammal, public Bird {
public:
    Bat() { 
        cout << "Bat constructor called\n"; 
    }
    
    void fly() { 
        cout << name << " flies in the sky\n"; 
    }
};

int main() {
    cout << "Creating a Bat object:\n";
    Bat myBat;
    
    cout << "\nSetting properties:\n";
    myBat.setName("Bruno");  // No ambiguity!
    myBat.setAge(3);         // No ambiguity!
    
    cout << "\nUsing inherited methods:\n";
    myBat.eat();             // No ambiguity!
    myBat.giveMilk();        // From Mammal
    myBat.layEggs();         // From Bird  
    myBat.fly();             // Bat's own method
    
    cout << "\nChecking consistency:\n";
    cout << "Bat's name: " << myBat.getName() << endl;
    cout << "Bat's age: " << myBat.getAge() << endl;
    
    return 0;
}
```

**Output:**
```
Creating a Bat object:
Animal constructor called
Mammal constructor called
Bird constructor called
Bat constructor called

Setting properties:
Name set to Bruno
Age set to 3

Using inherited methods:
Bruno (age 3) is eating
Bruno gives milk
Bruno lays eggs
Bruno flies in the sky

Checking consistency:
Bat's name: Bruno
Bat's age: 3
```

### Key Points About Virtual Inheritance

1. **Constructor Order:** In virtual inheritance, the virtual base class constructor is called first, regardless of inheritance order.

2. **Responsibility:** The most derived class (Bat) is responsible for initializing the virtual base class (Animal).

3. **Performance:** Virtual inheritance has slight overhead due to indirect access through virtual tables.

4. **When to Use:** Use virtual inheritance only when you have the diamond problem. Don't use it unnecessarily.

### Constructor Initialization in Virtual Inheritance

```cpp
class Animal {
    int age;
public:
    Animal(int a = 0) : age(a) { 
        cout << "Animal constructor: age = " << age << endl; 
    }
};

class Mammal : virtual public Animal {
public:
    Mammal(int a) : Animal(a) { 
        cout << "Mammal constructor\n"; 
    }
};

class Bird : virtual public Animal {
public:
    Bird(int a) : Animal(a) { 
        cout << "Bird constructor\n"; 
    }
};

class Bat : public Mammal, public Bird {
public:
    // Bat must directly initialize Animal (virtual base)
    Bat(int a) : Animal(a), Mammal(a), Bird(a) {
        cout << "Bat constructor\n";
    }
};
```

### Summary of Virtual Inheritance

**Benefits:**
- Solves ambiguity in multiple inheritance
- Ensures single copy of base class
- Maintains data consistency
- Enables proper polymorphism

**Drawbacks:**
- Slight performance overhead
- More complex constructor calls
- Additional memory for virtual pointers

**Best Practice:** Use virtual inheritance only when necessary to solve the diamond problem, not as a default choice.

---

**Summary:**  
Inheritance helps you organize and reuse code efficiently. Use it when you have an "is-a" relationship and want to avoid code duplication. Choose the type of inheritance that best models your problem. Be aware of the diamond problem in multipath/hybrid inheritance and use virtual inheritance when needed.
