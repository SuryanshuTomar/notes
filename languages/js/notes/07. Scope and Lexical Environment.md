# Scope, Scope Chain, and Lexical Environment

## Scope
Scope determines the accessibility of variables, functions, and objects in a program during runtime. It defines where a variable can be accessed or modified.

### Types of Scope:
1. **Global Scope**: Variables declared outside any function or block are in the global scope and accessible everywhere.

### Example Code:
```javascript
var globalVar = "I am global";

function test() {
    console.log(globalVar); // Output: I am global
}
test();
console.log(globalVar); // Output: I am global
```

### Key Points:
- Variables in the global scope are accessible from any part of the program.
- In browsers, global variables declared with `var` are added to the `window` object.
- Using `let` or `const` for global variables avoids polluting the `window` object.

### Visual Memory Representation:
- **Memory**: `{ globalVar: "I am global" }`
- **Lexical Environment**:
    ```
    Global Lexical Environment
    Environment Record: { globalVar: "I am global" }
    Outer: null
    ```
- **Call Stack**:
    ```
    [ Global Execution Context ]
    ```

---

2. **Function Scope**: Variables declared inside a function are accessible only within that function.

### Example Code:
```javascript
function testFunctionScope() {
    var functionVar = "I am in function scope";
    console.log(functionVar); // Output: I am in function scope
}
// console.log(functionVar); // Error: functionVar is not defined
testFunctionScope();
```

### Key Points:
- Variables declared with `var`, `let`, or `const` inside a function are scoped to that function.
- They cannot be accessed outside the function.

### Visual Memory Representation:
- **Memory (Inside Function)**: `{ functionVar: "I am in function scope" }`
- **Lexical Environment (Inside Function)**:
    ```
    Function Lexical Environment
    Environment Record: { functionVar: "I am in function scope" }
    Outer: Global Lexical Environment
    ```
- **Call Stack**:
    ```
    [ Function Execution Context ]
    [ Global Execution Context ]
    ```

---

3. **Block Scope**: Variables declared with `let` or `const` inside a block `{}` are accessible only within that block.

### Example Code:
```javascript
{
    let blockVar = "I am in block scope";
    const blockConst = "I am also in block scope";
    console.log(blockVar, blockConst); // Output: I am in block scope I am also in block scope
}
// console.log(blockVar, blockConst); // Error: blockVar and blockConst are not defined
```

### Key Points:
- Variables declared with `let` or `const` are block-scoped.
- They are not accessible outside the block in which they are declared.
- `var` does not respect block scope and is function-scoped instead.

### Visual Memory Representation:
- **Memory (Inside Block)**: `{ blockVar: "I am in block scope", blockConst: "I am also in block scope" }`
- **Lexical Environment (Inside Block)**:
    ```
    Block Lexical Environment
    Environment Record: { blockVar: "I am in block scope", blockConst: "I am also in block scope" }
    Outer: Parent Lexical Environment
    ```
- **Call Stack**:
    ```
    [ Block Execution Context ]
    [ Parent Execution Context ]
    ```

---

4. **Module Scope**: Variables declared in a module (using ES6 `import`/`export`) are scoped to that module and not accessible globally. This ensures encapsulation and avoids polluting the global scope.

### Example Code:
```javascript
// module1.js
export const a = 10;

// module2.js
import { a } from './module1.js';
console.log(a); // Output: 10
```

### Key Points:
- Variables in a module are not added to the global object.
- Each module has its own scope, and variables are accessible only within that module unless explicitly exported and imported.

### Visual Memory Representation:
- **Memory (module1.js)**: `{ a: 10 }`
- **Memory (module2.js)**: `{ a: 10 }`
- **Lexical Environment (module1.js)**:
    ```
    Module1 Lexical Environment
    Environment Record: { a: 10 }
    Outer: null
    ```
- **Lexical Environment (module2.js)**:
    ```
    Module2 Lexical Environment
    Environment Record: { a: 10 }
    Outer: null
    ```
- **Call Stack**:
    ```
    [ Module2 Execution Context ]
    [ Module1 Execution Context ]
    ```

---

5. **Script Scope**: In non-module scripts, variables declared with `var` outside any function are added to the global object. However, in modules, variables declared outside any function are scoped to the module and not added to the global object.

### Example Code:
```javascript
// Non-module script
var z = 30;
console.log(window.z); // Output: 30

// Module script
let w = 40;
console.log(window.w); // Output: undefined
```

### Key Points:
- In non-module scripts, `var` creates global variables accessible via the `window` object.
- In module scripts, variables are scoped to the module and do not pollute the global scope.
- Using `let` or `const` ensures block scoping even in non-module scripts.
- Modules are executed in strict mode by default.

### Visual Memory Representation:
- **Memory (Non-module script)**: `{ z: 30 }`
- **Memory (Module script)**: `{ w: 40 }`
- **Lexical Environment (Non-module script)**:
    ```
    Global Lexical Environment
    Environment Record: { z: 30 }
    Outer: null
    ```
- **Lexical Environment (Module script)**:
    ```
    Script Lexical Environment
    Environment Record: { w: 40 }
    Outer: null
    ```
- **Call Stack**:
    ```
    [ Script Execution Context ]
    [ Global Execution Context ]
    ```


These examples and visual representations illustrate how different scopes work in JavaScript.

---

## Lexical Environment
A **Lexical Environment** is a structure that holds variable bindings and references to its parent environment. It is created during the execution of code and consists of:
1. **Environment Record**: Stores variable and function declarations.
2. **Outer Lexical Environment Reference**: Points to the parent environment.

### Key Points:
- In basic terms, **Lexical Environment** of a function is the local scope + Lexical Environment of its parent.
- Lexical Environment is created for every function, block, and global scope.
- It is determined at the time of code writing (lexical analysis), not during runtime.

---

## Scope Chain
The **Scope Chain** is a mechanism to resolve variable access. When a variable is accessed, JavaScript looks for it in the current Lexical Environment. If not found, it traverses up the chain to the parent environment until it reaches the global scope.

---

## How They Are Connected
- **Scope** defines the accessibility of variables.
- **Lexical Environment** is the data structure that implements scope.
- **Scope Chain** connects multiple Lexical Environments to resolve variable access.

---

## Inner Working with Visual Representation

### Example Code:
```javascript
function outer() {
    let a = 10;
    function inner() {
        let b = 20;
        console.log(a + b);
    }
    inner();
}
outer();
```

### Step-by-Step Execution with Visual Representation:

#### Step 1: Global Execution Context
- **Memory**: `{ outer: <function> }`
- **Lexical Environment**:
    ```
    Global Lexical Environment
    Environment Record: { outer: <function> }
    Outer: null
    ```
- **Call Stack**:
    ```
    [ Global Execution Context ]
    ```
- **Execution Context Visual**:
    ```
    Global Execution Context:
    {
        Memory: { outer: <function> },
        Lexical Environment: {
            Environment Record: { outer: <function> },
            Outer: null
        }
    }
    ```

#### Step 2: Execution of `outer` Function
- **Memory**: `{ a: 10, inner: <function> }`
- **Lexical Environment**:
    ```
    Outer Lexical Environment
    Environment Record: { a: 10, inner: <function> }
    Outer: Global Lexical Environment
    ```
- **Call Stack**:
    ```
    [ outer Execution Context ]
    [ Global Execution Context ]
    ```
- **Execution Context Visual**:
    ```
    outer Execution Context:
    {
        Memory: { a: 10, inner: <function> },
        Lexical Environment: {
            Environment Record: { a: 10, inner: <function> },
            Outer: Global Lexical Environment
        }
    }
    ```

#### Step 3: Execution of `inner` Function
- **Memory**: `{ b: 20 }`
- **Lexical Environment**:
    ```
    Inner Lexical Environment
    Environment Record: { b: 20 }
    Outer: outer Lexical Environment
    ```
- **Call Stack**:
    ```
    [ inner Execution Context ]
    [ outer Execution Context ]
    [ Global Execution Context ]
    ```
- **Execution Context Visual**:
    ```
    inner Execution Context:
    {
        Memory: { b: 20 },
        Lexical Environment: {
            Environment Record: { b: 20 },
            Outer: outer Lexical Environment
        }
    }
    ```

#### Step 4: Variable Resolution and Output
- **Resolution of `a`**: Found in the `outer` Lexical Environment.
- **Resolution of `b`**: Found in the `inner` Lexical Environment.
- **Output**: `30` (from `console.log(a + b)`).
- **Call Stack After Execution**:
    ```
    [ Global Execution Context ]
    ```
- **Final State**:
    ```
    Global Execution Context:
    {
        Memory: { outer: <function> },
        Lexical Environment: {
            Environment Record: { outer: <function> },
            Outer: null
        }
    }
    ```
