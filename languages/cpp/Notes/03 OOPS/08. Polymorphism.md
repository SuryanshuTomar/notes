# Polymorphism in C++

## What is Polymorphism?

**Polymorphism** is derived from Greek words "poly" (many) and "morph" (forms), meaning "many forms". It is one of the core principles of Object-Oriented Programming that allows:

- **Same interface, different implementations**: Objects of different types can be accessed through the same interface
- **Code reusability and flexibility**: Write code once, use it for multiple types
- **Runtime and compile-time behavior selection**: Choose which method to call based on context

### Key Benefits:
- ✅ **Code Reusability**: Same function can work with different data types
- ✅ **Maintainability**: Easy to add new types without changing existing code
- ✅ **Flexibility**: Interface remains same while implementation varies
- ✅ **Abstraction**: Hide implementation details behind common interface

---

## Types of Polymorphism in C++

```
                    Polymorphism
                         |
            ┌────────────┴────────────┐
            │                        │
    Compile-Time                Runtime
    (Static)                   (Dynamic)
         |                        |
    ┌────┴────┐              ┌────┴────┐
    │         │              │         │
 Function  Operator      Virtual    Function
Overloading Overloading  Functions  Overriding
```

---

## 1. Compile-Time Polymorphism (Static Polymorphism)

Resolved during compilation. The compiler determines which function to call based on function signatures.

### 1.1 Function Overloading

**Definition**: Multiple functions with the same name but different parameters.

```cpp
#include <iostream>
using namespace std;

class Calculator {
public:
    // Same function name, different parameter types
    int add(int a, int b) {
        cout << "Adding integers: ";
        return a + b;
    }
    
    double add(double a, double b) {
        cout << "Adding doubles: ";
        return a + b;
    }
    
    int add(int a, int b, int c) {
        cout << "Adding three integers: ";
        return a + b + c;
    }
    
    string add(string a, string b) {
        cout << "Concatenating strings: ";
        return a + b;
    }
};

int main() {
    Calculator calc;
    
    cout << calc.add(5, 10) << endl;           // Calls int version
    cout << calc.add(3.5, 2.8) << endl;       // Calls double version
    cout << calc.add(1, 2, 3) << endl;        // Calls three-parameter version
    cout << calc.add("Hello", "World") << endl; // Calls string version
    
    return 0;
}
```

**Visual Representation:**
```
Function Call: calc.add(5, 10)
                    |
            Compiler Analysis
                    |
        ┌───────────┼───────────┐
        │           │           │
    add(int,int) add(double,double) add(int,int,int)
        │           │           │
    ✅ MATCH      ❌ NO MATCH   ❌ NO MATCH
        │
    Selected Function
```

### 1.2 Operator Overloading

**Definition**: Giving additional meanings to operators for user-defined types.

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
    
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // Overload + operator
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // Overload - operator
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    
    // Overload == operator
    bool operator==(const Complex& other) const {
        return (real == other.real && imag == other.imag);
    }
    
    // Overload << operator for output
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << c.real << " + " << c.imag << "i";
        return os;
    }
    
    // Overload [] operator
    double& operator[](int index) {
        if (index == 0) return real;
        else return imag;
    }
};

int main() {
    Complex c1(3, 4);
    Complex c2(1, 2);
    
    Complex c3 = c1 + c2;  // Uses overloaded + operator
    Complex c4 = c1 - c2;  // Uses overloaded - operator
    
    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c1 + c2: " << c3 << endl;
    cout << "c1 - c2: " << c4 << endl;
    cout << "c1 == c2: " << (c1 == c2) << endl;
    cout << "Real part of c1: " << c1[0] << endl;
    
    return 0;
}
```

**Visual Representation:**
```
Expression: c1 + c2
               |
         Operator+() Method
               |
    ┌──────────┼──────────┐
    │          │          │
  c1.real   c2.real   c1.imag   c2.imag
  (3.0)  +  (1.0)    (4.0)  +  (2.0)
    │          │          │          │
    └──────────┼──────────┘          │
            (4.0)                 (6.0)
               │                    │
               └────────┬───────────┘
                     New Complex(4.0, 6.0)
```

---

## 2. Runtime Polymorphism (Dynamic Polymorphism)

Resolved during runtime using virtual functions and inheritance.

### 2.1 Virtual Functions and Function Overriding

**Definition**: Functions in base class declared as virtual can be overridden in derived classes.

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// Base class
class Shape {
protected:
    string name;
    
public:
    Shape(string n) : name(n) {}
    
    // Virtual function - enables polymorphism
    virtual double area() const {
        cout << "Base Shape area calculation" << endl;
        return 0.0;
    }
    
    virtual void display() const {
        cout << "Shape: " << name << endl;
    }
    
    // Virtual destructor - important for proper cleanup
    virtual ~Shape() {
        cout << "Shape destructor called for " << name << endl;
    }
};

// Derived class 1
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : Shape("Circle"), radius(r) {}
    
    // Override virtual function
    double area() const override {
        cout << "Circle area calculation" << endl;
        return 3.14159 * radius * radius;
    }
    
    void display() const override {
        cout << "Circle with radius: " << radius << endl;
    }
    
    ~Circle() {
        cout << "Circle destructor called" << endl;
    }
};

// Derived class 2
class Rectangle : public Shape {
private:
    double length, width;
    
public:
    Rectangle(double l, double w) : Shape("Rectangle"), length(l), width(w) {}
    
    // Override virtual function
    double area() const override {
        cout << "Rectangle area calculation" << endl;
        return length * width;
    }
    
    void display() const override {
        cout << "Rectangle: " << length << " x " << width << endl;
    }
    
    ~Rectangle() {
        cout << "Rectangle destructor called" << endl;
    }
};

// Derived class 3
class Triangle : public Shape {
private:
    double base, height;
    
public:
    Triangle(double b, double h) : Shape("Triangle"), base(b), height(h) {}
    
    double area() const override {
        cout << "Triangle area calculation" << endl;
        return 0.5 * base * height;
    }
    
    void display() const override {
        cout << "Triangle: base=" << base << ", height=" << height << endl;
    }
    
    ~Triangle() {
        cout << "Triangle destructor called" << endl;
    }
};

// Function that demonstrates polymorphism
void printShapeInfo(const Shape& shape) {
    shape.display();
    cout << "Area: " << shape.area() << endl;
    cout << "------------------------" << endl;
}

int main() {
    cout << "=== Runtime Polymorphism Demo ===" << endl;
    
    // Create objects
    Circle circle(5.0);
    Rectangle rectangle(4.0, 6.0);
    Triangle triangle(8.0, 3.0);
    
    // Polymorphic function calls
    printShapeInfo(circle);      // Calls Circle's methods
    printShapeInfo(rectangle);   // Calls Rectangle's methods
    printShapeInfo(triangle);    // Calls Triangle's methods
    
    cout << "\n=== Polymorphic Container Demo ===" << endl;
    
    // Store different types in same container using base class pointers
    vector<unique_ptr<Shape>> shapes;
    shapes.push_back(make_unique<Circle>(3.0));
    shapes.push_back(make_unique<Rectangle>(5.0, 2.0));
    shapes.push_back(make_unique<Triangle>(6.0, 4.0));
    shapes.push_back(make_unique<Circle>(7.0));
    
    double totalArea = 0.0;
    for (const auto& shape : shapes) {
        shape->display();
        double area = shape->area();  // Polymorphic call
        totalArea += area;
        cout << "Area: " << area << endl;
        cout << "------------------------" << endl;
    }
    
    cout << "Total area of all shapes: " << totalArea << endl;
    
    return 0;
}
```

**Visual Representation of Virtual Function Call:**
```
Shape* ptr = new Circle(5.0);
ptr->area();
    |
    └─── Runtime Check ───┐
                          │
                      VTable Lookup
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
Shape VTable         Circle VTable         Rectangle VTable
├─ area()           ├─ area() ←─────────   ├─ area()
├─ display()        ├─ display()           ├─ display()
└─ destructor()     └─ destructor()        └─ destructor()
                          │
                    Calls Circle::area()
```

### 2.2 Abstract Classes and Pure Virtual Functions

**Definition**: Classes with at least one pure virtual function. Cannot be instantiated.

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// Abstract base class
class Animal {
protected:
    string name;
    int age;
    
public:
    Animal(string n, int a) : name(n), age(a) {}
    
    // Pure virtual functions - must be overridden
    virtual void makeSound() const = 0;
    virtual void move() const = 0;
    virtual string getType() const = 0;
    
    // Non-pure virtual function
    virtual void displayInfo() const {
        cout << "Name: " << name << ", Age: " << age << " years" << endl;
    }
    
    // Regular function
    string getName() const { return name; }
    int getAge() const { return age; }
    
    virtual ~Animal() = default;
};

class Dog : public Animal {
public:
    Dog(string n, int a) : Animal(n, a) {}
    
    void makeSound() const override {
        cout << name << " says: Woof! Woof!" << endl;
    }
    
    void move() const override {
        cout << name << " runs on four legs" << endl;
    }
    
    string getType() const override {
        return "Dog";
    }
    
    void displayInfo() const override {
        cout << "=== DOG INFO ===" << endl;
        Animal::displayInfo();  // Call base class method
        cout << "Type: " << getType() << endl;
    }
};

class Bird : public Animal {
private:
    bool canFly;
    
public:
    Bird(string n, int a, bool fly = true) : Animal(n, a), canFly(fly) {}
    
    void makeSound() const override {
        cout << name << " says: Tweet! Tweet!" << endl;
    }
    
    void move() const override {
        if (canFly) {
            cout << name << " flies in the sky" << endl;
        } else {
            cout << name << " walks on the ground" << endl;
        }
    }
    
    string getType() const override {
        return "Bird";
    }
    
    void displayInfo() const override {
        cout << "=== BIRD INFO ===" << endl;
        Animal::displayInfo();
        cout << "Type: " << getType() << endl;
        cout << "Can fly: " << (canFly ? "Yes" : "No") << endl;
    }
};

class Fish : public Animal {
public:
    Fish(string n, int a) : Animal(n, a) {}
    
    void makeSound() const override {
        cout << name << " says: Blub! Blub!" << endl;
    }
    
    void move() const override {
        cout << name << " swims in water" << endl;
    }
    
    string getType() const override {
        return "Fish";
    }
    
    void displayInfo() const override {
        cout << "=== FISH INFO ===" << endl;
        Animal::displayInfo();
        cout << "Type: " << getType() << endl;
    }
};

// Function that works with any Animal
void animalDemo(const Animal& animal) {
    animal.displayInfo();
    animal.makeSound();
    animal.move();
    cout << "--------------------------------" << endl;
}

int main() {
    cout << "=== Abstract Class Polymorphism Demo ===" << endl;
    
    // Animal animal("Generic", 1); // ERROR! Cannot instantiate abstract class
    
    // Create concrete objects
    Dog dog("Buddy", 3);
    Bird eagle("Eagle", 5, true);
    Bird penguin("Pingu", 2, false);
    Fish goldfish("Goldy", 1);
    
    // Polymorphic calls
    animalDemo(dog);
    animalDemo(eagle);
    animalDemo(penguin);
    animalDemo(goldfish);
    
    cout << "\n=== Zoo Management System ===" << endl;
    
    // Store different animals in container
    vector<unique_ptr<Animal>> zoo;
    zoo.push_back(make_unique<Dog>("Rex", 4));
    zoo.push_back(make_unique<Bird>("Tweety", 2));
    zoo.push_back(make_unique<Fish>("Nemo", 1));
    zoo.push_back(make_unique<Dog>("Max", 6));
    
    cout << "All animals in the zoo:" << endl;
    for (const auto& animal : zoo) {
        cout << "- " << animal->getName() << " (" << animal->getType() << ")" << endl;
    }
    
    cout << "\nFeeding time - all animals make sounds:" << endl;
    for (const auto& animal : zoo) {
        animal->makeSound();
    }
    
    cout << "\nExercise time - all animals move:" << endl;
    for (const auto& animal : zoo) {
        animal->move();
    }
    
    return 0;
}
```

---

## 3. Advanced Polymorphism Concepts

### 3.1 Template Polymorphism (Generic Programming)

**Definition**: Compile-time polymorphism using templates for type-independent code.

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Function template - works with any type
template<typename T>
void printValue(const T& value) {
    cout << "Value: " << value << endl;
}

// Function template with multiple parameters
template<typename T, typename U>
auto add(const T& a, const U& b) -> decltype(a + b) {
    return a + b;
}

// Class template
template<typename T>
class Container {
private:
    vector<T> items;
    
public:
    void add(const T& item) {
        items.push_back(item);
    }
    
    T get(size_t index) const {
        if (index < items.size()) {
            return items[index];
        }
        throw out_of_range("Index out of range");
    }
    
    size_t size() const {
        return items.size();
    }
    
    void display() const {
        cout << "Container contents: ";
        for (const auto& item : items) {
            cout << item << " ";
        }
        cout << endl;
    }
};

// Template specialization
template<>
class Container<string> {
private:
    vector<string> items;
    
public:
    void add(const string& item) {
        items.push_back(item);
    }
    
    string get(size_t index) const {
        if (index < items.size()) {
            return items[index];
        }
        return "NOT_FOUND";
    }
    
    size_t size() const {
        return items.size();
    }
    
    void display() const {
        cout << "String Container: ";
        for (const auto& item : items) {
            cout << "\"" << item << "\" ";
        }
        cout << endl;
    }
};

int main() {
    cout << "=== Template Polymorphism Demo ===" << endl;
    
    // Function template usage
    printValue(42);           // int
    printValue(3.14);         // double
    printValue("Hello");      // const char*
    printValue(string("World")); // string
    
    cout << "\nTemplate function with multiple types:" << endl;
    cout << "5 + 3.2 = " << add(5, 3.2) << endl;
    cout << "2.5 + 7 = " << add(2.5, 7) << endl;
    
    // Class template usage
    cout << "\n=== Container Templates ===" << endl;
    
    Container<int> intContainer;
    intContainer.add(10);
    intContainer.add(20);
    intContainer.add(30);
    intContainer.display();
    
    Container<double> doubleContainer;
    doubleContainer.add(1.5);
    doubleContainer.add(2.7);
    doubleContainer.add(3.9);
    doubleContainer.display();
    
    // Specialized template
    Container<string> stringContainer;
    stringContainer.add("Apple");
    stringContainer.add("Banana");
    stringContainer.add("Cherry");
    stringContainer.display();
    
    return 0;
}
```

### 3.2 RTTI (Run-Time Type Information)

**Definition**: Mechanism to determine object type at runtime.

```cpp
#include <iostream>
#include <typeinfo>
#include <vector>
#include <memory>
using namespace std;

class Base {
public:
    virtual ~Base() = default;
    virtual void print() const {
        cout << "Base class" << endl;
    }
};

class Derived1 : public Base {
public:
    void print() const override {
        cout << "Derived1 class" << endl;
    }
    
    void specificMethod1() const {
        cout << "Derived1 specific method" << endl;
    }
};

class Derived2 : public Base {
public:
    void print() const override {
        cout << "Derived2 class" << endl;
    }
    
    void specificMethod2() const {
        cout << "Derived2 specific method" << endl;
    }
};

void demonstrateRTTI(Base* ptr) {
    cout << "Object type: " << typeid(*ptr).name() << endl;
    
    // dynamic_cast for safe downcasting
    if (Derived1* d1 = dynamic_cast<Derived1*>(ptr)) {
        cout << "Successfully cast to Derived1" << endl;
        d1->specificMethod1();
    }
    else if (Derived2* d2 = dynamic_cast<Derived2*>(ptr)) {
        cout << "Successfully cast to Derived2" << endl;
        d2->specificMethod2();
    }
    else {
        cout << "Cast failed - object is Base or unknown type" << endl;
    }
    
    cout << "------------------------" << endl;
}

int main() {
    cout << "=== RTTI Demo ===" << endl;
    
    vector<unique_ptr<Base>> objects;
    objects.push_back(make_unique<Base>());
    objects.push_back(make_unique<Derived1>());
    objects.push_back(make_unique<Derived2>());
    
    for (auto& obj : objects) {
        obj->print();
        demonstrateRTTI(obj.get());
    }
    
    return 0;
}
```

---

## 4. Benefits and Drawbacks

### Benefits:
- **Code Reusability**: Write once, use for multiple types
- **Maintainability**: Easy to extend without modifying existing code
- **Flexibility**: Switch implementations without changing client code
- **Abstraction**: Hide implementation details behind interfaces

### Drawbacks:
- **Runtime Overhead**: Virtual function calls are slightly slower
- **Memory Overhead**: VTable storage for each class
- **Complexity**: Can make code harder to understand for beginners
- **Debugging**: Runtime polymorphism can be harder to debug

---

## 5. Best Practices

### ✅ Do:
1. **Use virtual destructors** in base classes
2. **Mark overridden functions with `override`** keyword
3. **Prefer smart pointers** over raw pointers
4. **Use abstract base classes** to define interfaces
5. **Keep virtual functions focused** and well-defined

### ❌ Don't:
1. **Don't call virtual functions in constructors/destructors**
2. **Don't make every function virtual** unnecessarily
3. **Avoid deep inheritance hierarchies**
4. **Don't ignore the performance implications**

---

## 6. Real-World Example: Drawing Application

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// Abstract base class
class Drawable {
protected:
    int x, y;
    string color;
    
public:
    Drawable(int x, int y, string color) : x(x), y(y), color(color) {}
    
    // Pure virtual functions
    virtual void draw() const = 0;
    virtual double area() const = 0;
    virtual string getInfo() const = 0;
    
    // Common functionality
    void move(int dx, int dy) {
        x += dx;
        y += dy;
        cout << "Moved to (" << x << ", " << y << ")" << endl;
    }
    
    virtual ~Drawable() = default;
};

class Circle : public Drawable {
private:
    double radius;
    
public:
    Circle(int x, int y, string color, double r) 
        : Drawable(x, y, color), radius(r) {}
    
    void draw() const override {
        cout << "Drawing " << color << " circle at (" << x << ", " << y 
             << ") with radius " << radius << endl;
    }
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    string getInfo() const override {
        return "Circle: " + color + ", radius=" + to_string(radius);
    }
};

class Rectangle : public Drawable {
private:
    double width, height;
    
public:
    Rectangle(int x, int y, string color, double w, double h) 
        : Drawable(x, y, color), width(w), height(h) {}
    
    void draw() const override {
        cout << "Drawing " << color << " rectangle at (" << x << ", " << y 
             << ") with dimensions " << width << "x" << height << endl;
    }
    
    double area() const override {
        return width * height;
    }
    
    string getInfo() const override {
        return "Rectangle: " + color + ", " + to_string(width) + "x" + to_string(height);
    }
};

// Drawing canvas that works with any drawable object
class Canvas {
private:
    vector<unique_ptr<Drawable>> shapes;
    
public:
    void addShape(unique_ptr<Drawable> shape) {
        shapes.push_back(move(shape));
    }
    
    void drawAll() const {
        cout << "\n=== Drawing Canvas ===" << endl;
        for (const auto& shape : shapes) {
            shape->draw();
        }
    }
    
    void printInfo() const {
        cout << "\n=== Canvas Information ===" << endl;
        double totalArea = 0;
        for (const auto& shape : shapes) {
            cout << shape->getInfo() << " (Area: " << shape->area() << ")" << endl;
            totalArea += shape->area();
        }
        cout << "Total area: " << totalArea << endl;
    }
};

int main() {
    Canvas canvas;
    
    // Add different shapes to canvas
    canvas.addShape(make_unique<Circle>(10, 20, "Red", 5.0));
    canvas.addShape(make_unique<Rectangle>(30, 40, "Blue", 8.0, 6.0));
    canvas.addShape(make_unique<Circle>(50, 60, "Green", 3.0));
    canvas.addShape(make_unique<Rectangle>(70, 80, "Yellow", 4.0, 4.0));
    
    // Use polymorphism to work with all shapes uniformly
    canvas.drawAll();
    canvas.printInfo();
    
    return 0;
}
```

---

## Summary

Polymorphism is a powerful feature in C++ that enables:

1. **Compile-time polymorphism** through function/operator overloading and templates
2. **Runtime polymorphism** through virtual functions and inheritance
3. **Code flexibility** and reusability through common interfaces
4. **Type safety** with proper design patterns

Understanding and effectively using polymorphism is crucial for writing maintainable, extensible, and efficient C++ code.
