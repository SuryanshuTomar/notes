# File Handling in C++

## Table of Contents
1. [Introduction](#introduction)
2. [File Stream Classes](#file-stream-classes)
3. [Opening and Closing Files](#opening-and-closing-files)
4. [File Modes](#file-modes)
5. [Reading from Files](#reading-from-files)
6. [Writing to Files](#writing-to-files)
7. [File Position Pointers](#file-position-pointers)
8. [Binary File Operations](#binary-file-operations)
9. [Error Handling](#error-handling)
10. [Best Practices](#best-practices)
11. [Advanced Topics](#advanced-topics)

## Introduction

File handling in C++ allows programs to store and retrieve data permanently. C++ provides a rich set of classes and functions through the `<fstream>` header to perform file operations.

### Why File Handling?
- **Persistent Storage**: Data survives program termination
- **Data Exchange**: Share data between different programs
- **Large Data Sets**: Handle data too large for memory
- **Configuration**: Store program settings and preferences

## File Stream Classes

C++ provides three main file stream classes:

### 1. `ifstream` (Input File Stream)
- Used for **reading** from files
- Inherits from `istream`
- Default mode: `ios::in`

### 2. `ofstream` (Output File Stream)
- Used for **writing** to files
- Inherits from `ostream`
- Default mode: `ios::out`

### 3. `fstream` (File Stream)
- Used for **both reading and writing**
- Inherits from `iostream`
- Can be opened in various modes

```cpp
#include <fstream>
#include <iostream>
using namespace std;

// Reading only
ifstream inputFile;

// Writing only
ofstream outputFile;

// Reading and writing
fstream file;
```

## Opening and Closing Files

### Opening Files

#### Method 1: Using Constructor
```cpp
ifstream inputFile("data.txt");
ofstream outputFile("output.txt");
fstream file("data.txt", ios::in | ios::out); // read and write mode
fstream file("data.txt", ios::app); // append mode
```

#### Method 2: Using `open()` Method
```cpp
ifstream inputFile;
inputFile.open("data.txt");

ofstream outputFile;
outputFile.open("output.txt", ios::app); // append mode

fstream file;
file.open("data.txt", ios::in | ios::out | ios::binary);
```

### Closing Files

#### Explicit Closing
```cpp
inputFile.close();
outputFile.close();
file.close();
```

#### Automatic Closing
- Files are automatically closed when the object goes out of scope
- Destructor handles the closing

### Checking if File is Open
```cpp
if (inputFile.is_open()) {
    cout << "File opened successfully" << endl;
} else {
    cout << "Failed to open file" << endl;
}
```

## File Modes

File modes determine how a file is opened and what operations are allowed:

| Mode | Description | Usage |
|------|-------------|--------|
| `ios::in` | Input mode (reading) | Default for `ifstream` |
| `ios::out` | Output mode (writing) | Default for `ofstream` |
| `ios::app` | Append mode | Write at end of file |
| `ios::ate` | At end | Open and seek to end |
| `ios::trunc` | Truncate | Clear file contents |
| `ios::binary` | Binary mode | Handle binary data |

### Combining Modes
```cpp
// Open for reading and writing
fstream file("data.txt", ios::in | ios::out);

// Open for writing, create if doesn't exist, append to end
ofstream file("log.txt", ios::out | ios::app);

// Open binary file for reading and writing
fstream file("data.bin", ios::in | ios::out | ios::binary);

// Open for writing, truncate if exists
ofstream file("temp.txt", ios::out | ios::trunc);
```

## Reading from Files

### 1. Reading Character by Character
```cpp
ifstream file("data.txt");
char ch;

while (file.get(ch)) {
    cout << ch;
}
```

### 2. Reading Word by Word
```cpp
ifstream file("data.txt");
string word;

while (file >> word) {
    cout << word << " ";
}
```

### 3. Reading Line by Line
```cpp
ifstream file("data.txt");
string line;

while (getline(file, line)) {
    cout << line << endl;
}
```

### 4. Reading Entire File
```cpp
ifstream file("data.txt");
string content;
string line;

while (getline(file, line)) {
    content += line + "\n";
}

cout << content;
```

### 5. Reading with Custom Delimiter
```cpp
ifstream file("data.csv");
string field;

while (getline(file, field, ',')) {
    cout << field << " | ";
}
```

## Writing to Files

### 1. Writing Strings
```cpp
ofstream file("output.txt");

file << "Hello, World!" << endl;
file << "C++ File Handling" << endl;
```

### 2. Writing Numbers
```cpp
ofstream file("numbers.txt");

for (int i = 1; i <= 10; i++) {
    file << i << " ";
}
```

### 3. Writing Formatted Data
```cpp
ofstream file("data.txt");

file << fixed << setprecision(2);
file << "Price: $" << 29.99 << endl;
file << "Tax: $" << 2.40 << endl;
```

### 4. Appending to Files
```cpp
ofstream file("log.txt", ios::app);

file << "New log entry: " << getCurrentTime() << endl;
```

## File Position Pointers

File streams maintain position pointers that keep track of the current position in the file.

### Get Position Pointers
- `tellg()`: Get position for reading (get pointer)
- `tellp()`: Get position for writing (put pointer)

### Set Position Pointers
- `seekg()`: Set position for reading
- `seekp()`: Set position for writing

```cpp
fstream file("data.txt", ios::in | ios::out);

// Get current positions
streampos readPos = file.tellg();
streampos writePos = file.tellp();

// Move to beginning
file.seekg(0, ios::beg);

// Move to end
file.seekg(0, ios::end);

// Move to specific position
file.seekg(10, ios::beg);  // 10 bytes from beginning

// Relative positioning
file.seekg(5, ios::cur);   // 5 bytes from current position
file.seekg(-3, ios::cur);  // 3 bytes backward from current position
```

### Seek Directions
- `ios::beg`: Beginning of file
- `ios::cur`: Current position
- `ios::end`: End of file

## Binary File Operations

Binary files store data in binary format, which is more efficient for non-text data.

### Writing Binary Data
```cpp
#include <fstream>
using namespace std;

struct Student {
    int id;
    char name[50];
    float marks;
};

int main() {
    ofstream file("students.dat", ios::binary);
    
    Student s1 = {101, "John Doe", 85.5};
    
    // Write entire structure
    file.write((char*)&s1, sizeof(Student));
    
    // Write individual data
    int number = 42;
    file.write((char*)&number, sizeof(int));
    
    file.close();
    return 0;
}
```

### Reading Binary Data
```cpp
ifstream file("students.dat", ios::binary);

Student s1;

// Read entire structure
file.read((char*)&s1, sizeof(Student));

cout << "ID: " << s1.id << endl;
cout << "Name: " << s1.name << endl;
cout << "Marks: " << s1.marks << endl;

// Read individual data
int number;
file.read((char*)&number, sizeof(int));
cout << "Number: " << number << endl;
```

### Binary File with Arrays
```cpp
// Writing array to binary file
int numbers[] = {1, 2, 3, 4, 5};
ofstream file("numbers.dat", ios::binary);
file.write((char*)numbers, sizeof(numbers));

// Reading array from binary file
int readNumbers[5];
ifstream inputFile("numbers.dat", ios::binary);
inputFile.read((char*)readNumbers, sizeof(readNumbers));
```

## Error Handling

### Stream State Flags
File streams maintain state flags to indicate various conditions:

- `good()`: No error flags set
- `eof()`: End of file reached
- `fail()`: Logical error (e.g., type mismatch)
- `bad()`: Read/write error
- `clear()`: Clear error flags

```cpp
ifstream file("data.txt");

if (!file) {
    cerr << "Error opening file!" << endl;
    return 1;
}

string line;
while (getline(file, line)) {
    cout << line << endl;
    
    if (file.bad()) {
        cerr << "Error reading file!" << endl;
        break;
    }
}

if (file.eof()) {
    cout << "End of file reached successfully" << endl;
}
```

### Exception Handling with Files
```cpp
#include <fstream>
#include <iostream>
#include <stdexcept>

try {
    ifstream file("nonexistent.txt");
    file.exceptions(ifstream::failbit | ifstream::badbit);
    
    string line;
    while (getline(file, line)) {
        cout << line << endl;
    }
} catch (const ifstream::failure& e) {
    cerr << "Exception: " << e.what() << endl;
}
```

## Best Practices

### 1. Always Check File Operations
```cpp
ifstream file("data.txt");
if (!file.is_open()) {
    cerr << "Error: Could not open file" << endl;
    return 1;
}
```

### 2. Use RAII (Resource Acquisition Is Initialization)
```cpp
// File automatically closed when object goes out of scope
{
    ifstream file("data.txt");
    // ... use file
} // file.close() called automatically
```

### 3. Handle Exceptions
```cpp
try {
    ofstream file("output.txt");
    file.exceptions(ofstream::failbit | ofstream::badbit);
    file << "Some data" << endl;
} catch (const exception& e) {
    cerr << "File operation failed: " << e.what() << endl;
}
```

### 4. Use Appropriate File Modes
```cpp
// For logging - append mode
ofstream logFile("app.log", ios::app);

// For temporary files - truncate mode
ofstream tempFile("temp.txt", ios::trunc);

// For binary data - binary mode
ofstream binaryFile("data.bin", ios::binary);
```

### 5. Flush Buffers When Necessary
```cpp
ofstream file("important.txt");
file << "Critical data" << endl;
file.flush(); // Ensure data is written immediately
```

## Advanced Topics

### 1. File Copying
```cpp
void copyFile(const string& source, const string& destination) {
    ifstream src(source, ios::binary);
    ofstream dst(destination, ios::binary);
    
    if (!src || !dst) {
        throw runtime_error("Cannot open files for copying");
    }
    
    dst << src.rdbuf(); // Copy entire file
}
```

### 2. File Size Calculation
```cpp
long getFileSize(const string& filename) {
    ifstream file(filename, ios::binary | ios::ate);
    if (!file) return -1;
    
    return file.tellg();
}
```

### 3. Random Access Files
```cpp
// Create a file with numbered records
ofstream file("records.txt");
for (int i = 0; i < 10; i++) {
    file << "Record " << i << endl;
}
file.close();

// Random access reading
ifstream readFile("records.txt");
readFile.seekg(0, ios::end);
long fileSize = readFile.tellg();

// Jump to middle of file
readFile.seekg(fileSize / 2);
string line;
getline(readFile, line);
cout << "Middle record: " << line << endl;
```

### 4. CSV File Handling
```cpp
#include <sstream>
#include <vector>

vector<vector<string>> readCSV(const string& filename) {
    vector<vector<string>> data;
    ifstream file(filename);
    string line;
    
    while (getline(file, line)) {
        vector<string> row;
        stringstream ss(line);
        string cell;
        
        while (getline(ss, cell, ',')) {
            row.push_back(cell);
        }
        data.push_back(row);
    }
    
    return data;
}

void writeCSV(const string& filename, const vector<vector<string>>& data) {
    ofstream file(filename);
    
    for (const auto& row : data) {
        for (size_t i = 0; i < row.size(); i++) {
            file << row[i];
            if (i < row.size() - 1) file << ",";
        }
        file << endl;
    }
}
```

### 5. Memory-Mapped Files (Advanced)
```cpp
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

// Note: This is platform-specific (Unix/Linux)
void memoryMappedFileExample() {
    int fd = open("largefile.dat", O_RDONLY);
    if (fd == -1) return;
    
    // Get file size
    off_t fileSize = lseek(fd, 0, SEEK_END);
    
    // Map file to memory
    char* mappedData = (char*)mmap(nullptr, fileSize, PROT_READ, MAP_PRIVATE, fd, 0);
    
    if (mappedData != MAP_FAILED) {
        // Access file data as memory
        cout << "First byte: " << mappedData[0] << endl;
        
        // Unmap when done
        munmap(mappedData, fileSize);
    }
    
    close(fd);
}
```

## Common File Operations Examples

### 1. Log File Manager
```cpp
class Logger {
private:
    ofstream logFile;
    string filename;

public:
    Logger(const string& file) : filename(file) {
        logFile.open(filename, ios::app);
    }
    
    ~Logger() {
        if (logFile.is_open()) {
            logFile.close();
        }
    }
    
    void log(const string& message) {
        if (logFile.is_open()) {
            auto now = chrono::system_clock::now();
            auto time_t = chrono::system_clock::to_time_t(now);
            
            logFile << "[" << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "] ";
            logFile << message << endl;
            logFile.flush();
        }
    }
};
```

### 2. Configuration File Handler
```cpp
class ConfigManager {
private:
    map<string, string> config;
    string configFile;
    
public:
    ConfigManager(const string& file) : configFile(file) {
        loadConfig();
    }
    
    void loadConfig() {
        ifstream file(configFile);
        string line;
        
        while (getline(file, line)) {
            size_t pos = line.find('=');
            if (pos != string::npos) {
                string key = line.substr(0, pos);
                string value = line.substr(pos + 1);
                config[key] = value;
            }
        }
    }
    
    void saveConfig() {
        ofstream file(configFile);
        for (const auto& pair : config) {
            file << pair.first << "=" << pair.second << endl;
        }
    }
    
    string getValue(const string& key) {
        return config[key];
    }
    
    void setValue(const string& key, const string& value) {
        config[key] = value;
    }
};
```

## Summary

File handling in C++ is a powerful feature that enables:
- **Persistent data storage** using `ifstream`, `ofstream`, and `fstream`
- **Flexible file access** with various modes and position control
- **Binary operations** for efficient data storage
- **Error handling** mechanisms for robust file operations
- **Advanced techniques** for specialized use cases

Remember to always:
- Check file operations for success
- Handle exceptions appropriately
- Use RAII for automatic resource management
- Choose appropriate file modes for your use case
- Flush buffers when immediate write is required

File handling is essential for real-world applications that need to persist data, configuration, logs, and communicate with other systems.