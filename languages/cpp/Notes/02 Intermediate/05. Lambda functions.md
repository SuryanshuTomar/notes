# Lambda Functions in C++

## What are Lambda Functions?

Lambda functions are anonymous function objects introduced in C++11. They allow you to define functions inline, making code more concise and readable, especially when working with STL algorithms.

**Basic Syntax:**
```cpp
[capture_clause](parameters) -> return_type { body }
```

## Components of Lambda Functions

### 1. Capture Clause `[]`
- `[]` - Capture nothing
- `[=]` - Capture all by value
- `[&]` - Capture all by reference
- `[var]` - Capture `var` by value
- `[&var]` - Capture `var` by reference
- `[=, &var]` - Capture all by value except `var` by reference

### 2. Parameter List `()`
- Optional if no parameters
- Same as regular function parameters

### 3. Return Type `-> type`
- Optional, compiler can deduce
- Required for complex return types

## Assigning Lambdas to Variables

You can assign lambdas to variables and reuse them later:

### Using `auto` (Recommended)
```cpp
// Simple lambda assignment
auto add = [](int a, int b) { return a + b; };
auto multiply = [](int x, int y) -> int { return x * y; };

// Using the assigned lambdas
int result1 = add(5, 3);        // 8
int result2 = multiply(4, 6);   // 24

// Lambda with captures
int factor = 10;
auto scale = [factor](int value) { return value * factor; };
int scaled = scale(5);          // 50
```

### Using `std::function`
```cpp
#include <functional>

// More flexible but with slight overhead
std::function<int(int, int)> operation = [](int a, int b) { return a + b; };
std::function<void()> printer = []() { std::cout << "Hello!\n"; };

// Can reassign to different compatible lambdas
operation = [](int a, int b) { return a * b; };
int result = operation(3, 4);   // 12

// Useful for function parameters and class members
class Calculator {
private:
    std::function<int(int, int)> operation;
    
public:
    void setOperation(std::function<int(int, int)> op) {
        operation = op;
    }
    
    int calculate(int a, int b) {
        return operation ? operation(a, b) : 0;
    }
};
```

### Lambda Variables in Different Scopes
```cpp
// Global lambda variable
auto globalLambda = [](const std::string& msg) {
    std::cout << "Global: " << msg << std::endl;
};

class MyClass {
private:
    // Class member lambda
    std::function<bool(int)> validator;
    
public:
    MyClass() {
        // Initialize in constructor
        validator = [](int x) { return x > 0 && x < 100; };
    }
    
    void processValue(int value) {
        if (validator(value)) {
            std::cout << "Valid value: " << value << std::endl;
        }
    }
    
    // Method returning lambda
    auto getFormatter() {
        return [](int num) -> std::string {
            return "Number: " + std::to_string(num);
        };
    }
};

void demonstrateUsage() {
    // Local lambda variables
    auto isEven = [](int n) { return n % 2 == 0; };
    auto square = [](int x) { return x * x; };
    
    // Use them multiple times
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};
    
    for (int num : numbers) {
        if (isEven(num)) {
            std::cout << square(num) << " ";
        }
    }
    
    // Get lambda from method
    MyClass obj;
    auto formatter = obj.getFormatter();
    std::cout << formatter(42) << std::endl;  // "Number: 42"
}
```

### Storing Lambdas in Containers
```cpp
#include <vector>
#include <map>

// Vector of lambdas
std::vector<std::function<int(int)>> operations = {
    [](int x) { return x + 1; },
    [](int x) { return x * 2; },
    [](int x) { return x * x; }
};

// Apply all operations
int value = 5;
for (const auto& op : operations) {
    value = op(value);
}
std::cout << value << std::endl;  // ((5+1)*2)^2 = 144

// Map of named lambdas
std::map<std::string, std::function<double(double, double)>> calculators = {
    {"add", [](double a, double b) { return a + b; }},
    {"subtract", [](double a, double b) { return a - b; }},
    {"multiply", [](double a, double b) { return a * b; }},
    {"divide", [](double a, double b) { return b != 0 ? a / b : 0; }}
};

// Use by name
double result = calculators["multiply"](3.5, 2.0);  // 7.0
```

## Common Use Cases

### 1. STL Algorithms

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> numbers = {1, 2, 3, 4, 5};

// Find even numbers
auto even = std::find_if(numbers.begin(), numbers.end(), 
    [](int n) { return n % 2 == 0; });

// Transform elements
std::transform(numbers.begin(), numbers.end(), numbers.begin(),
    [](int n) { return n * n; });

// Sort with custom comparator
std::sort(numbers.begin(), numbers.end(),
    [](int a, int b) { return a > b; }); // Descending order
```

### 2. Event Handling and Callbacks

```cpp
#include <functional>

class Button {
public:
    std::function<void()> onClick;
    
    void click() {
        if (onClick) onClick();
    }
};

Button btn;
btn.onClick = []() { std::cout << "Button clicked!\n"; };
btn.click();
```

### 3. Local Helper Functions

```cpp
void processData() {
    auto validate = [](const std::string& data) {
        return !data.empty() && data.length() > 3;
    };
    
    auto format = [](std::string& data) {
        std::transform(data.begin(), data.end(), data.begin(), ::toupper);
    };
    
    std::string input = "hello";
    if (validate(input)) {
        format(input);
        std::cout << input << std::endl;
    }
}
```

## Capture Examples

### Value Capture
```cpp
int x = 10;
auto lambda1 = [x]() { 
    // x is copied, original x unchanged
    return x * 2; 
};
```

### Reference Capture
```cpp
int x = 10;
auto lambda2 = [&x]() { 
    x *= 2; // Modifies original x
    return x; 
};
```

### Mixed Capture
```cpp
int a = 1, b = 2, c = 3;
auto lambda3 = [=, &c](int d) {
    // a, b copied by value
    // c captured by reference
    c = a + b + d;
    return c;
};
```

### Generalized Capture (C++14)
```cpp
auto lambda4 = [ptr = std::make_unique<int>(42)](int x) {
    return *ptr + x;
};

// Move capture
std::string str = "Hello";
auto lambda5 = [s = std::move(str)]() {
    return s + " World";
};
```

## Advanced Features

### Generic Lambdas (C++14)
```cpp
auto generic = [](auto a, auto b) {
    return a + b;
};

std::cout << generic(1, 2) << std::endl;        // int + int
std::cout << generic(1.5, 2.5) << std::endl;   // double + double
std::cout << generic(std::string("Hello"), std::string(" World")) << std::endl;
```

### Recursive Lambdas
```cpp
std::function<int(int)> factorial = [&](int n) -> int {
    return n <= 1 ? 1 : n * factorial(n - 1);
};

std::cout << factorial(5) << std::endl; // 120
```

### Immediately Invoked Lambda
```cpp
auto result = [](int x, int y) {
    return x * y;
}(5, 10); // Called immediately with arguments

std::cout << result << std::endl; // 50
```

## Tips and Tricks

### 1. Prefer `auto` for Lambda Variables
```cpp
// Good
auto lambda = [](int x) { return x * 2; };

// Avoid (verbose)
std::function<int(int)> lambda2 = [](int x) { return x * 2; };
```

### 2. Use `mutable` for Modifying Captured Values
```cpp
int counter = 0;
auto increment = [counter]() mutable {
    return ++counter; // Modifies the copy
};
```

### 3. Avoid Capturing `this` by Value
```cpp
class MyClass {
private:
    int value = 42;
    
public:
    void badExample() {
        // Dangerous: captures this by value (copies entire object)
        auto lambda = [=]() { return value; };
    }
    
    void goodExample() {
        // Better: explicit capture or capture this by reference
        auto lambda1 = [this]() { return value; };
        auto lambda2 = [&]() { return value; };
        auto lambda3 = [value = this->value]() { return value; }; // C++14
    }
};
```

### 4. Use Lambda for Complex Initialization
```cpp
const auto complexData = [&]() {
    std::vector<int> data;
    // Complex initialization logic
    for (int i = 0; i < 100; ++i) {
        if (someCondition(i)) {
            data.push_back(process(i));
        }
    }
    return data;
}();
```

### 5. Combining with Standard Algorithms
```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// Chain multiple operations
auto result = std::accumulate(
    numbers.begin(), 
    numbers.end(), 
    0,
    [](int sum, int n) { 
        return n % 2 == 0 ? sum + n : sum; 
    }
);

// Count elements with condition
auto count = std::count_if(numbers.begin(), numbers.end(),
    [](int n) { return n > 5; });

// Transform and filter in pipeline
std::vector<int> processed;
std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(processed),
    [](int n) { return n % 2 != 0; });
```

## When to Use Lambdas

### ✅ Good Use Cases:
- Short, simple functions used once
- STL algorithm predicates
- Event callbacks
- Local helper functions
- Functional programming patterns

### ❌ Avoid When:
- Function is complex or reused multiple times
- Logic needs to be tested separately
- Function needs to be part of class interface
- Performance is critical (consider function objects)

## Performance Considerations

Lambdas are typically as fast as function pointers or function objects. The compiler often inlines them, resulting in zero overhead.

```cpp
// These are often equivalent in performance
auto lambda = [](int x) { return x * 2; };
int function(int x) { return x * 2; }
struct Functor { int operator()(int x) { return x * 2; } };
```