# Abstraction in C++

## What is Abstraction?

Abstraction is one of the fundamental principles of Object-Oriented Programming (OOP) that focuses on hiding implementation details while showing only essential features to the user. It allows us to create a simplified interface that represents complex underlying operations.

```
Real World Example:
Car Dashboard
┌─────────────────────────┐
│  🚗 Car Dashboard      │
│                         │
│  [Speed] [Fuel] [Temp] │
│  [Start] [Stop]         │
└─────────────────────────┘
         ↓
Hidden Complex Engine Operations
```

## Types of Abstraction in C++

### 1. Data Abstraction
Hiding internal data representation and exposing only necessary operations.

```cpp
class BankAccount {
private:
    double balance;      // Hidden implementation
    string accountNo;    // Hidden implementation
    
public:
    void deposit(double amount);     // Interface
    void withdraw(double amount);    // Interface
    double getBalance();            // Interface
};
```

**Visual Representation:**
```
┌─────────────────────────┐
│    Public Interface     │
│  ┌─────────────────────┐│
│  │ deposit()           ││
│  │ withdraw()          ││
│  │ getBalance()        ││
│  └─────────────────────┘│
├─────────────────────────┤
│    Private Data         │
│  ┌─────────────────────┐│
│  │ balance             ││
│  │ accountNo           ││
│  │ validationLogic()   ││
│  └─────────────────────┘│
└─────────────────────────┘
```

### 2. Functional Abstraction
Hiding complex function implementations behind simple interfaces.

```cpp
class Calculator {
public:
    double calculateArea(double radius) {
        // Complex mathematical operations hidden
        return 3.14159 * radius * radius;
    }
    
private:
    void complexValidation();
    void errorHandling();
    void logging();
};
```

## Virtual Functions and Pure Virtual Functions

### Virtual Functions
Virtual functions enable runtime polymorphism in C++ by allowing derived classes to override base class methods. The correct function is called based on the object's actual type, not the pointer/reference type.

**What it is:** A function declared with the `virtual` keyword in a base class that can be overridden in derived classes.

**What it's for:** Enables dynamic dispatch and polymorphic behavior at runtime.

```cpp
class Animal {
public:
    virtual void makeSound() {
        cout << "Animal makes a sound" << endl;
    }
    
    virtual void move() {
        cout << "Animal moves" << endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Dog barks: Woof!" << endl;
    }
    
    void move() override {
        cout << "Dog runs on four legs" << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        cout << "Cat meows: Meow!" << endl;
    }
};
```

**Virtual Function Mechanism:**
```
Compile Time:          Runtime:
                      
Base* ptr;            ptr points to Dog object
                           ↓
┌─────────────┐       ┌─────────────┐
│   Animal    │  -->  │ Dog Object  │
│             │       │             │
│ virtual     │       │ vtable ptr  │---┐
│ makeSound() │       │             │   │
└─────────────┘       └─────────────┘   │
                                        │
                                        ▼
                                 ┌─────────────┐
                                 │  Dog vtable │
                                 │             │
                                 │Dog::makeSound│
                                 │Dog::move     │
                                 └─────────────┘
```

### Pure Virtual Functions
Pure virtual functions are virtual functions with no implementation in the base class, making the class abstract.

**What it is:** A virtual function declared with `= 0`, having no implementation in the base class.

**What it's for:** Forces derived classes to provide their own implementation and creates abstract base classes.

```cpp
class Shape {
protected:
    string name;
    
public:
    Shape(string n) : name(n) {}
    
    // Pure virtual functions
    virtual double calculateArea() = 0;
    virtual double calculatePerimeter() = 0;
    virtual void draw() = 0;
    
    // Concrete function
    string getName() { return name; }
    
    virtual ~Shape() {}
};

class Rectangle : public Shape {
private:
    double length, width;
    
public:
    Rectangle(string n, double l, double w) : Shape(n), length(l), width(w) {}
    
    double calculateArea() override {
        return length * width;
    }
    
    double calculatePerimeter() override {
        return 2 * (length + width);
    }
    
    void draw() override {
        cout << "Drawing " << name << " rectangle" << endl;
    }
};
```

**Pure Virtual Function Structure:**
```
┌─────────────────────────┐
│      Shape (Abstract)   │
│                         │
│ +getName()              │ ← Concrete
│ +calculateArea() = 0    │ ← Pure Virtual
│ +calculatePerimeter()=0 │ ← Pure Virtual
│ +draw() = 0             │ ← Pure Virtual
└─────────────────────────┘
            ▲
            │ inherits
┌─────────────────────────┐
│   Rectangle (Concrete)  │
│                         │
│ +calculateArea()        │ ← Must implement
│ +calculatePerimeter()   │ ← Must implement
│ +draw()                 │ ← Must implement
└─────────────────────────┘
```

## Implementation Methods in C++

### 1. Abstract Classes

Abstract classes contain at least one pure virtual function and cannot be instantiated.

```cpp
// Abstract Base Class
class Vehicle {
protected:
    string brand;
    int year;
    
public:
    Vehicle(string b, int y) : brand(b), year(y) {}
    
    // Pure virtual functions (makes class abstract)
    virtual void startEngine() = 0;
    virtual void stopEngine() = 0;
    virtual double getFuelEfficiency() = 0;
    
    // Concrete methods
    void setBrand(string b) { brand = b; }
    string getBrand() { return brand; }
    
    virtual ~Vehicle() {}
};

// Concrete Implementation
class Car : public Vehicle {
private:
    double engineSize;
    bool isRunning;
    
public:
    Car(string b, int y, double engine) : Vehicle(b, y), engineSize(engine), isRunning(false) {}
    
    void startEngine() override {
        isRunning = true;
        cout << brand << " car engine started" << endl;
    }
    
    void stopEngine() override {
        isRunning = false;
        cout << brand << " car engine stopped" << endl;
    }
    
    double getFuelEfficiency() override {
        return 25.5; // MPG
    }
};
```

### 2. Interface Implementation

Creating pure interfaces using abstract classes with only pure virtual functions.

```cpp
// Pure Interface
class Drawable {
public:
    virtual void draw() = 0;
    virtual void resize(double factor) = 0;
    virtual ~Drawable() {}
};

class Printable {
public:
    virtual void print() = 0;
    virtual void printPreview() = 0;
    virtual ~Printable() {}
};

// Multiple Interface Implementation
class Document : public Drawable, public Printable {
private:
    string content;
    double width, height;
    
public:
    Document(string c) : content(c), width(8.5), height(11.0) {}
    
    void draw() override {
        cout << "Drawing document on screen" << endl;
    }
    
    void resize(double factor) override {
        width *= factor;
        height *= factor;
    }
    
    void print() override {
        cout << "Printing: " << content << endl;
    }
    
    void printPreview() override {
        cout << "Preview: " << content.substr(0, 50) << "..." << endl;
    }
};
```

## Real-World Example: Media Player

```cpp
// Abstract Media Player
class MediaPlayer {
public:
    virtual void play() = 0;
    virtual void pause() = 0;
    virtual void stop() = 0;
    virtual void setVolume(int level) = 0;
    virtual ~MediaPlayer() {}
};

// Concrete Implementation
class AudioPlayer : public MediaPlayer {
private:
    string filename;
    bool isPlaying;
    int volume;
    
    // Hidden complex operations
    void loadCodec();
    void bufferAudio();
    void processAudio();
    
public:
    AudioPlayer(string file) : filename(file), isPlaying(false), volume(50) {}
    
    void play() override {
        loadCodec();      // Hidden
        bufferAudio();    // Hidden
        isPlaying = true;
        cout << "Playing: " << filename << endl;
    }
    
    void pause() override {
        isPlaying = false;
        cout << "Paused" << endl;
    }
    
    void stop() override {
        isPlaying = false;
        cout << "Stopped" << endl;
    }
    
    void setVolume(int level) override {
        volume = (level >= 0 && level <= 100) ? level : volume;
    }
};
```

**Visual Representation:**
```
Media Player Interface (Abstract)
┌─────────────────────────────────────┐
│         🎵 Media Player            │
│                                     │
│  Public Interface (Abstract)        │
│  ┌─────────────────────────────────┐│
│  │ ▶️  play()                      ││
│  │ ⏸️  pause()                     ││
│  │ ⏹️  stop()                      ││
│  │ 🔊 setVolume(level)             ││
│  └─────────────────────────────────┘│
└─────────────────────────────────────┘
                

## Benefits of Abstraction

- **Simplicity**: Complex operations hidden behind simple interfaces
- **Modularity**: Code organized into logical, manageable units
- **Maintainability**: Implementation changes don't affect client code
- **Reusability**: Abstract interfaces can be implemented in multiple ways
- **Security**: Internal implementation details are protected

## Best Practices

1. **Design clear interfaces** with minimal, essential operations
2. **Use pure virtual functions** for true abstraction
3. **Provide virtual destructors** in abstract base classes
4. **Document interface contracts** clearly
5. **Keep abstraction levels consistent** throughout the design
