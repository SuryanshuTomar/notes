# Single Responsibility Principle (SRP)

## What is the Single Responsibility Principle?
The Single Responsibility Principle (SRP) is one of the five SOLID principles of object-oriented design. It states:  
**"A class should have only one reason to change."**  

In simpler terms, a class should only have one responsibility or purpose. This ensures that the class is focused, easier to maintain, and less prone to bugs when changes are made.

---

## Why is SRP Important?
1. **Improved Maintainability**: Classes with a single responsibility are easier to understand and modify.  
2. **Reduced Coupling**: SRP reduces dependencies between different parts of the code.  
3. **Enhanced Testability**: Focused classes are easier to test.  
4. **Scalability**: SRP makes it easier to extend functionality without breaking existing code.

---

## What Should Be Done in SRP?
- **Focus on One Responsibility**: Ensure each class has a single, well-defined purpose.  
- **Separate Concerns**: Break down complex functionalities into smaller, independent classes.  
- **Encapsulate Behavior**: Group related behaviors into their own classes.  

## What Should Not Be Done in SRP?
- **Avoid Mixing Responsibilities**: Do not combine unrelated functionalities in a single class.  
- **Do Not Overcomplicate**: Avoid creating unnecessary classes for trivial responsibilities.  
- **Avoid Tight Coupling**: Do not make classes overly dependent on each other.

---

## Difference Between Good and Bad Design

### Bad Design
- Classes handle multiple unrelated responsibilities.  
- Changes in one functionality can inadvertently affect others.  
- Code becomes harder to maintain, test, and scale.  

### Good Design
- Classes are focused on a single responsibility.  
- Changes are isolated to specific classes, reducing the risk of side effects.  
- Code is modular, easier to understand, and scalable.

---

## Real-Life Examples

### Example 1: Employee Management System  
**Bad Design**:  
```cpp
class Employee {
public:
    void calculateSalary() {
        // Logic for salary calculation
    }

    void saveToDatabase() {
        // Logic for saving employee data to database
    }

    void generateReport() {
        // Logic for generating employee report
    }
};
```
Here, the `Employee` class has multiple responsibilities: salary calculation, database operations, and report generation. Any change in one responsibility might affect the others.

**Good Design**:  
```cpp
class Employee {
public:
    void calculateSalary() {
        // Logic for salary calculation
    }
};

class EmployeeDatabase {
public:
    void saveToDatabase() {
        // Logic for saving employee data to database
    }
};

class EmployeeReport {
public:
    void generateReport() {
        // Logic for generating employee report
    }
};
```
Each class now has a single responsibility, making the code easier to maintain and extend.

---

### Example 2: Online Shopping Cart  
**Bad Design**:  
```cpp
class ShoppingCart {
public:
    void addItem() {
        // Logic for adding item to cart
    }

    void calculateTotal() {
        // Logic for calculating total price
    }

    void sendEmailNotification() {
        // Logic for sending email notification
    }
};
```
The `ShoppingCart` class handles adding items, calculating totals, and sending notifications, violating SRP.

**Good Design**:  
```cpp
class ShoppingCart {
public:
    void addItem() {
        // Logic for adding item to cart
    }
};

class PaymentProcessor {
public:
    void calculateTotal() {
        // Logic for calculating total price
    }
};

class NotificationService {
public:
    void sendEmailNotification() {
        // Logic for sending email notification
    }
};
```
Each class now has a single responsibility.

---

## Visual Representations

### Diagram 1: Bad Design  
```
+-------------------+
|    Employee       |
|-------------------|
| calculateSalary   |
| saveToDatabase    |
| generateReport    |
+-------------------+
```

### Diagram 2: Good Design  
```
+-------------------+       +-------------------+       +-------------------+
|    Employee       |       | EmployeeDatabase |       | EmployeeReport    |
|-------------------|       |-------------------|       |-------------------|
| calculateSalary   |       | saveToDatabase   |       | generateReport    |
+-------------------+       +-------------------+       +-------------------+
```

---

### Diagram 3: Online Shopping Cart  
**Bad Design**:  
```
+-------------------+
| ShoppingCart      |
|-------------------|
| addItem           |
| calculateTotal    |
| sendEmail         |
+-------------------+
```

**Good Design**:  
```
+-------------------+       +-------------------+       +-------------------+
| ShoppingCart      |       | PaymentProcessor |       | NotificationService|
|-------------------|       |-------------------|       |-------------------|
| addItem           |       | calculateTotal   |       | sendEmail         |
+-------------------+       +-------------------+       +-------------------+
```

---

## Key Takeaways
- A class should have only one reason to change.  
- SRP promotes cleaner, modular, and maintainable code.  
- Breaking down responsibilities into separate classes reduces complexity and improves scalability.
- Avoid mixing unrelated functionalities in a single class.
- Focus on creating classes with clear, single responsibilities.
- Good design leads to better maintainability, testability, and scalability.
