# Object-Oriented Programming (OOP) Notes

## What is Object-Oriented Programming (OOP)?

Object-Oriented Programming is a programming paradigm that organizes code around objects and classes rather than functions and logic. It's based on the concept of "objects" which contain data (attributes) and code (methods).

### Core Principles of OOP:
1. **Encapsulation** - Bundling data and methods together
2. **Inheritance** - Creating new classes based on existing ones
3. **Polymorphism** - Same interface, different implementations
4. **Abstraction** - Hiding complex implementation details

---

## What is a Class?

A **class** is a blueprint or template that defines the structure and behavior of objects. It specifies what attributes (data) and methods (functions) the objects will have.

### Example:
```cpp
class Car {
private:
    string brand;
    string model;
    int year;
    
public:
    // Constructor
    Car(string b, string m, int y) {
        brand = b;
        model = m;
        year = y;
    }
    
    // Methods
    void startEngine() {
        cout << "Engine started!" << endl;
    }
    
    void displayInfo() {
        cout << brand << " " << model << " (" << year << ")" << endl;
    }
};
```

---

## What is an Object?

An **object** is an instance of a class. It's a real entity that has actual values for the attributes defined in the class and can perform the actions (methods) defined in the class.

### Example:
```cpp
int main() {
    // Creating objects (instances) of Car class
    Car car1("Toyota", "Camry", 2022);
    Car car2("Honda", "Civic", 2021);
    
    // Using object methods
    car1.startEngine();
    car1.displayInfo();
    
    car2.startEngine();
    car2.displayInfo();
    
    return 0;
}
```

---

## Difference Between Class and Object
---------------------------------------------------------
| **Class**           | **Object**                      |
|---------------------|---------------------------------|
| Blueprint/Template  | Instance of a class             |
| Defines structure   | Has actual values               |
| No memory allocated | Memory is allocated             |
| Logical entity      | Physical entity                 |   
| Declared once       | Multiple objects can be created |
---------------------------------------------------------

### Real-world Analogy:
- **Class**: House blueprint (shows rooms, layout, etc.)
- **Object**: Actual house built from that blueprint

---

## When to Use OOP Concepts?

### 1. **Large and Complex Applications**
```cpp
// Example: Banking System
class BankAccount {
private:
    string accountNumber;
    double balance;
    string ownerName;
    
public:
    void deposit(double amount);
    void withdraw(double amount);
    double getBalance();
    void transfer(BankAccount& toAccount, double amount);
};
```

### 2. **Code Reusability is Important**
```cpp
// Base class
class Animal {
public:
    virtual void makeSound() = 0;
    virtual void move() = 0;
};

// Derived classes reusing Animal structure
class Dog : public Animal {
public:
    void makeSound() override { cout << "Woof!" << endl; }
    void move() override { cout << "Running on four legs" << endl; }
};

class Bird : public Animal {
public:
    void makeSound() override { cout << "Tweet!" << endl; }
    void move() override { cout << "Flying with wings" << endl; }
};
```

### 3. **Data Security is Crucial**
```cpp
class PasswordManager {
private:
    string password;  // Encapsulated - cannot be accessed directly
    
public:
    bool setPassword(string newPassword) {
        if(newPassword.length() >= 8) {
            password = newPassword;
            return true;
        }
        return false;
    }
    
    bool validatePassword(string inputPassword) {
        return password == inputPassword;
    }
};
```

### 4. **Modeling Real-World Entities**
```cpp
class Student {
private:
    string name;
    int rollNumber;
    vector<double> grades;
    
public:
    Student(string n, int roll) : name(n), rollNumber(roll) {}
    
    void addGrade(double grade) {
        grades.push_back(grade);
    }
    
    double calculateGPA() {
        double sum = 0;
        for(double grade : grades) {
            sum += grade;
        }
        return sum / grades.size();
    }
};
```

### 5. **Team Development**
OOP allows different developers to work on different classes independently:

```cpp
// Developer 1 works on User class
class User {
    // User implementation
};

// Developer 2 works on Database class
class Database {
    // Database implementation
};

// Developer 3 works on UI class
class UserInterface {
    // UI implementation
};
```

---

## Benefits of Using OOP

1. **Modularity** - Code is organized in separate, manageable units
2. **Reusability** - Classes can be reused in different parts of the program
3. **Maintainability** - Easier to update and modify code
4. **Scalability** - Easy to add new features
5. **Data Security** - Encapsulation protects data from unauthorized access

---

## When NOT to Use OOP

- **Simple scripts** or small programs
- **Performance-critical applications** where function calls overhead matters
- **Mathematical computations** where procedural approach is more natural
- **System programming** where low-level control is needed

Remember: Choose OOP when you need structure, reusability, and maintainability in your code!

## Memory Layout of Objects

### How Objects Occupy Memory at Runtime

When an object is created, memory is allocated to store:
1. **Instance variables (data members)** - Each object gets its own copy
2. **Virtual function table pointer (vptr)** - If the class has virtual functions
3. **Padding bytes** - For memory alignment

**Note**: Methods are NOT stored in each object - they're stored in code segment and shared by all objects.

### Memory Size Calculation

```cpp
class Example {
private:
    int a;        // 4 bytes
    char b;       // 1 byte
    double c;     // 8 bytes
    bool d;       // 1 byte
public:
    void display() { /* methods don't take object memory */ }
};

// Memory layout with padding:
// int a:    [****] (4 bytes)
// char b:   [*___] (1 byte + 3 padding)
// double c: [********] (8 bytes) 
// bool d:   [*_______] (1 byte + 7 padding)
// Total: 4 + 4 + 8 + 8 = 24 bytes (due to alignment)
```

### Understanding Memory Padding in Detail

**Why Padding Exists:**
- **CPU Efficiency**: Processors access memory faster when data is aligned to specific boundaries
- **Hardware Requirement**: Some architectures require aligned access to prevent crashes
- **Performance**: Misaligned access can be 2-10x slower

### Alignment Rules:
```cpp
// Basic alignment requirements (typical 64-bit system):
char   - 1 byte alignment (can start at any address)
short  - 2 byte alignment (must start at even address)
int    - 4 byte alignment (must start at address divisible by 4)
long   - 8 byte alignment (must start at address divisible by 8)
double - 8 byte alignment (must start at address divisible by 8)
```

### Detailed Padding Examples:

#### Example 1: Order Matters
```cpp
class BadOrder {
    char a;    // 1 byte
    int b;     // 4 bytes (needs 4-byte alignment)
    char c;    // 1 byte
    double d;  // 8 bytes (needs 8-byte alignment)
};

// Memory layout:
// Address: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23
// Data:   [a][_][_][_][b][b][b][b][c][_][_][_][_][_][_][_][d][d][d][d][d][d][d][d]
//           | padding |             |      padding       |
// Total: 24 bytes

class GoodOrder {
    double d;  // 8 bytes
    int b;     // 4 bytes
    char a;    // 1 byte
    char c;    // 1 byte
};

// Memory layout:
// Address: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
// Data:    [d][d][d][d][d][d][d][d][b][b][b][b][a][c][_][_]
//                                                  |padding|
// Total: 16 bytes (8 bytes saved!)
```

#### Example 2: Struct Padding Rules
```cpp
struct PaddingDemo {
    char a;      // Offset 0, size 1
    // 3 bytes padding here for int alignment
    int b;       // Offset 4, size 4
    char c;      // Offset 8, size 1
    // 7 bytes padding here for double alignment
    double d;    // Offset 16, size 8
    char e;      // Offset 24, size 1
    // 7 bytes padding at end for struct alignment
};
// Total size: 32 bytes

// Visual representation:
/*
Byte:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
Data: [a][_][_][_][b][b][b][b][c][_][_][_][_][_][_][_][d][d][d][d][d][d][d][d][e][_][_][_][_][_][_][_]
        | padding |             |        padding     |                           |   final padding   |
*/
```

#### Example 3: Compiler-Specific Alignment
```cpp
#include <iostream>
using namespace std;

struct TestStruct {
    char a;
    int b;
    char c;
    double d;
};

int main() {
    TestStruct obj;
    
    cout << "Size of struct: " << sizeof(TestStruct) << " bytes" << endl;
    cout << "Address of a: " << (void*)&obj.a << endl;
    cout << "Address of b: " << (void*)&obj.b << endl;
    cout << "Address of c: " << (void*)&obj.c << endl;
    cout << "Address of d: " << (void*)&obj.d << endl;
    
    // Calculate offsets
    cout << "Offset of a: " << offsetof(TestStruct, a) << endl;
    cout << "Offset of b: " << offsetof(TestStruct, b) << endl;
    cout << "Offset of c: " << offsetof(TestStruct, c) << endl;
    cout << "Offset of d: " << offsetof(TestStruct, d) << endl;
    
    return 0;
}

/* Typical output:
Size of struct: 24 bytes
Offset of a: 0
Offset of b: 4    (3 bytes padding after 'a')
Offset of c: 8    
Offset of d: 16   (7 bytes padding after 'c')
*/
```

### Controlling Padding:

#### 1. Using #pragma pack
```cpp
#pragma pack(1)  // No padding
struct NoPadding {
    char a;    // Offset 0
    int b;     // Offset 1 (no padding!)
    char c;    // Offset 5
    double d;  // Offset 6 (no padding!)
};
// Size: 14 bytes (but slower access!)
#pragma pack()  // Reset to default

#pragma pack(2)  // 2-byte alignment
struct TwoBytePack {
    char a;    // Offset 0
    int b;     // Offset 2 (1 byte padding)
    char c;    // Offset 6
    double d;  // Offset 8 (1 byte padding)
};
// Size: 16 bytes
#pragma pack()
```

#### 2. Using alignas (C++11)
```cpp
struct CustomAlign {
    alignas(16) char a;    // 'a' aligned to 16-byte boundary
    int b;
};
// Size will be at least 16 bytes due to alignas
```

### Memory Visualization Tool:
```cpp
template<typename T>
void showMemoryLayout() {
    T obj;
    cout << "Object size: " << sizeof(T) << " bytes" << endl;
    cout << "Object address: " << &obj << endl;
    
    // Show each byte
    unsigned char* ptr = reinterpret_cast<unsigned char*>(&obj);
    for(size_t i = 0; i < sizeof(T); ++i) {
        cout << "Byte " << i << ": " << (void*)(ptr + i) << endl;
    }
}
```

### Best Practices for Memory Layout:
1. **Order members by size (largest first)** to minimize padding
2. **Group related small members** together
3. **Use bit fields** for boolean flags when memory is critical
4. **Consider cache line alignment** for performance-critical code
5. **Profile before optimizing** - readability vs. memory savings

### Visual Memory Representation

```cpp
class Point {
    int x;    // 4 bytes
    int y;    // 4 bytes
};

Point p1(10, 20);
Point p2(30, 40);

// Memory Layout:
// Object p1:  [   10   ][   20   ]  (8 bytes)
//              x value   y value
//
// Object p2:  [   30   ][   40   ]  (8 bytes)  
//              x value   y value
//
// Each object has its own memory space
```

### Complete Example with Memory Analysis

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int rollNo;       // 4 bytes
    char grade;       // 1 byte (+ 3 padding)
    double marks;     // 8 bytes
    bool isActive;    // 1 byte (+ 7 padding)
    
public:
    Student(int r, char g, double m, bool a) 
        : rollNo(r), grade(g), marks(m), isActive(a) {}
    
    void display() {
        cout << "Roll: " << rollNo << ", Grade: " << grade 
             << ", Marks: " << marks << ", Active: " << isActive << endl;
    }
};

int main() {
    cout << "Size of Student class: " << sizeof(Student) << " bytes" << endl;
    // Output: 24 bytes (4 + 4 + 8 + 8 due to padding)
    
    Student s1(101, 'A', 95.5, true);
    Student s2(102, 'B', 87.2, true);
    
    cout << "Address of s1: " << &s1 << endl;
    cout << "Address of s2: " << &s2 << endl;
    // Different memory addresses for each object
    
    return 0;
}
```

---

## Why Empty Class Takes 1 Byte

### The Empty Class Problem

```cpp
class Empty {
    // No data members
    // No methods
};

int main() {
    cout << sizeof(Empty) << endl;  // Output: 1 byte
    return 0;
}
```

### Reasons for 1 Byte Size:

1. **Object Identity**: Every object must have a unique memory address
2. **Pointer Arithmetic**: Arrays of empty objects need distinct addresses
3. **C++ Standard Requirement**: Each object must occupy at least 1 byte

### Visual Explanation:

```cpp
class Empty {};

int main() {
    Empty obj1;
    Empty obj2;
    Empty arr[3];
    
    cout << "obj1 address: " << &obj1 << endl;  // e.g., 0x7fff123
    cout << "obj2 address: " << &obj2 << endl;  // e.g., 0x7fff124
    
    cout << "arr[0] address: " << &arr[0] << endl;  // e.g., 0x7fff125
    cout << "arr[1] address: " << &arr[1] << endl;  // e.g., 0x7fff126
    cout << "arr[2] address: " << &arr[2] << endl;  // e.g., 0x7fff127
    
    return 0;
}

// Memory Layout:
// obj1: [*] (1 byte)
// obj2: [*] (1 byte) 
// arr:  [*][*][*] (3 bytes total, 1 byte each)
```

### What Happens Without the 1-Byte Rule:

```cpp
// If empty classes had 0 size (hypothetical):
Empty arr[5];  // How would you access arr[1], arr[2]?
Empty* ptr = &arr[0];
ptr++;  // Where would this point? Undefined behavior!

// With 1-byte rule:
Empty arr[5];  // Takes 5 bytes
Empty* ptr = &arr[0];  // Points to address X
ptr++;  // Points to address X+1 (arr[1])
```

### Empty Base Optimization (EBO):

```cpp
class Empty {};

class Derived : public Empty {
    int value;  // 4 bytes
};

int main() {
    cout << sizeof(Empty) << endl;    // 1 byte
    cout << sizeof(Derived) << endl;  // 4 bytes (not 5!)
    // Empty base class doesn't add to size
    return 0;
}
```

The compiler optimizes away the empty base class size when it's inherited, but standalone empty objects still need 1 byte for unique addressing.
