# Block, Block Scope, and Shadowing  

## 1. What is a Block in JavaScript?  
- A **block** in JavaScript is a set of statements enclosed within curly braces `{}`. It is used to group multiple statements together, often in control structures like `if`, `for`, or `while`.  
- Block is also known as **Compound Statement**

### Example:  
```javascript
{
    let x = 10;
    console.log(x); // Output: 10
}
console.log(typeof x); // Output: undefined (x is not accessible outside the block)
```  

### Visual Representation:  
```
{
    [ Block Start ]
        let x = 10;
        console.log(x); // Inside block
    [ Block End ]
}
console.log(x); // Outside block
```

---

## 2. What is Block Scope?  
**Block scope** means that variables declared with `let` or `const` inside a block are only accessible within that block. Variables declared with `var` do not have block scope; they are function-scoped or globally scoped.  

### Example:  
```javascript
{
    let a = 5;
    const b = 10;
    var c = 15;
    console.log(a, b, c); // Output: 5, 10, 15
}
console.log(typeof a); // Output: undefined (a is block-scoped)
console.log(typeof b); // Output: undefined (b is block-scoped)
console.log(c);        // Output: 15 (c is not block-scoped)
```  

### Visual Representation:  
```
Block Scope:
{
    let a = 5;  // Accessible only inside the block
    const b = 10; // Accessible only inside the block
    var c = 15; // Accessible outside the block
}
```

---

## 3. What is Lexical Scope Chain?  
**Lexical scope** refers to the fact that a variable's scope is determined by its position in the source code. Inner functions have access to variables declared in their outer functions or blocks.  

### Example:  
```javascript
function outer() {
    let x = 10;
    function inner() {
        console.log(x); // Output: 10 (x is accessible due to lexical scope)
    }
    inner();
}
outer();
```  

### Visual Representation:  
```
outer() {
    let x = 10;  // Outer scope
    inner() {
        console.log(x);  // Accesses x from outer scope
    }
}
```
---  

## 3.1 More on Lexical Scope Chain  

The **lexical scope chain** is a fundamental concept in JavaScript that determines how variable names are resolved in nested functions. When a variable is accessed, JavaScript starts looking for it in the current scope. If it doesn't find the variable there, it moves outward to the parent scope, continuing this process until it reaches the global scope. If the variable is not found in any scope, a `ReferenceError` is thrown.

### Key Points:
1. **Static Scoping**: Lexical scope is determined at the time of writing the code, not during runtime. This means the structure of the code dictates the scope, regardless of where functions are called from.
2. **Scope Chain**: Each function creates its own scope. When a variable is accessed, JavaScript traverses the chain of scopes outward to resolve the variable.
3. **Global Scope**: The outermost scope is the global scope, which is accessible from anywhere in the code unless shadowed by a local variable.

### Example with Nested Functions:
```javascript
function outer() {
    let a = 10;
    function middle() {
        let b = 20;
        function inner() {
            let c = 30;
            console.log(a, b, c); // Output: 10, 20, 30
        }
        inner();
    }
    middle();
}
outer();
```

### Explanation:
- `inner()` has access to `c` (its own variable), `b` (from `middle()`), and `a` (from `outer()`).
- The scope chain for `inner()` is: `inner -> middle -> outer -> global`.

### Visual Representation:
```
Global Scope:
    [ Variables declared outside any function ]
    outer() {
        let a = 10;  // Outer scope
        middle() {
            let b = 20;  // Middle scope
            inner() {
                let c = 30;  // Inner scope
                console.log(a, b, c);  // Accesses variables from all scopes
            }
        }
    }
```

### Practical Use Case:
Lexical scoping is the foundation for closures in JavaScript. A closure is created when an inner function "remembers" variables from its outer function, even after the outer function has finished executing.

#### Example of Closure:
```javascript
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // Output: 1
console.log(counter()); // Output: 2

```

Here, the inner function retains access to the `count` variable from the outer function due to lexical scoping.

### Summary:
Understanding lexical scope and the scope chain is crucial for writing predictable and bug-free JavaScript code. It helps in debugging variable access issues and is the basis for advanced concepts like closures.

---

## 4. What is Shadowing?  
**Shadowing** occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable "shadows" the outer variable within its scope.  

### Example:  
```javascript
let x = 20;
{
    let x = 10; // Shadows the outer x
    console.log(x); // Output: 10
}
console.log(x); // Output: 20
```  

### Visual Representation:  
```
Global Scope:
    let x = 20;

Block Scope:
    let x = 10;  // Shadows global x
```

---

## 5. What is Illegal Shadowing?  
**Illegal shadowing** occurs when a `let` or `const` variable tries to shadow a `var` variable in the same scope. This is not allowed and will throw an error.  

### Example:  
```javascript
var x = 20;
{
    // let x = 10; // Error: Cannot redeclare block-scoped variable 'x'
}
```  

### Visual Representation:  
```
var x = 20;  // Global scope
{
    let x = 10;  // Illegal shadowing (Error)
}
```
---

### Reference Video  
For a detailed explanation, watch this [YouTube video](https://www.youtube.com/watch?v=lW_erSjyMeM&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=10).