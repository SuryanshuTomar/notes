# C++ Const Keywords

## const Variables

**What**: Variables whose values cannot be modified after initialization.

```cpp
const int x = 10;  // x cannot be changed
const std::string name = "John";  // name is immutable
```

**Why**: 
- Prevents accidental modifications
- Enables compiler optimizations
- Self-documenting code
- Thread safety for read-only data

**When to use**: When you have values that shouldn't change during program execution.

**Scenarios**:
```cpp
// 1. Function parameters - prevent modification
void process(const std::vector<int>& data) {
    // data cannot be modified, only read
}

// 2. Class members - immutable after construction
class Person {
    const int id;  // Set once in constructor
public:
    Person(int i) : id(i) {}
};

// 3. Local constants
void calculate() {
    const double PI = 3.14159;
    const auto config = getConfiguration();  // Won't change
}

// 4. Const correctness in methods
class Calculator {
    int value;
public:
    int getValue() const { return value; }  // Doesn't modify object
};
```

## constexpr

**What**: Indicates that a value or function can be evaluated at compile time.

```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}
constexpr int result = factorial(5);  // Computed at compile time
```

**Why**:
- Compile-time computation reduces runtime overhead
- Can be used in contexts requiring constant expressions
- Enables template metaprogramming

**When to use**: For values/functions that can be computed at compile time and you want performance benefits.

**Scenarios**:
```cpp
// 1. Compile-time constants
constexpr int BUFFER_SIZE = 1024;
constexpr double PI = 3.14159265359;

// 2. Template parameters
template<int N>
class Array {
    int data[N];  // N must be compile-time constant
};
Array<BUFFER_SIZE> buffer;  // Uses constexpr value

// 3. Constexpr functions (can be called at runtime too)
constexpr int max(int a, int b) {
    return a > b ? a : b;
}
constexpr int compile_time = max(10, 20);  // Compile time
int runtime_val = max(x, y);              // Runtime if x,y not constexpr

// 4. Complex compile-time computations
constexpr int fibonacci(int n) {
    return n <= 1 ? n : fibonacci(n-1) + fibonacci(n-2);
}
constexpr auto fib_10 = fibonacci(10);  // Computed at compile time

// 5. Constexpr constructors
class Point {
    int x, y;
public:
    constexpr Point(int x, int y) : x(x), y(y) {}
    constexpr int getX() const { return x; }
};
constexpr Point origin(0, 0);  // Created at compile time
```

## consteval (C++20)

**What**: Forces functions to be evaluated at compile time only.

```cpp
consteval int square(int x) {
    return x * x;
}
constexpr int a = square(5);  // OK: compile time
// int b = square(runtime_var);  // ERROR: must be compile time
```

**Why**:
- Guarantees compile-time evaluation
- Prevents accidental runtime calls
- Better error messages for compile-time requirements

**When to use**: When you want to ensure a function is only called at compile time.

**Scenarios**:
```cpp
// 1. Immediate functions - compile-time only
consteval int power_of_2(int exp) {
    return 1 << exp;
}
constexpr int result = power_of_2(8);  // OK: 256 at compile time
// int bad = power_of_2(user_input);   // ERROR: not compile time

// 2. Type traits and metaprogramming
consteval bool is_power_of_2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
static_assert(is_power_of_2(8));   // Compile-time check
static_assert(!is_power_of_2(6));  // Compile-time check

// 3. Configuration validation
consteval int validate_config(int threads) {
    if (threads <= 0 || threads > 128) {
        throw "Invalid thread count";  // Compile-time error
    }
    return threads;
}
constexpr int THREAD_COUNT = validate_config(4);  // Validated at compile time

// 4. Code generation helpers
consteval const char* get_build_info() {
    return "Built on " __DATE__ " at " __TIME__;
}
constexpr auto build_info = get_build_info();  // Embedded at compile time
```

## constinit (C++20)

**What**: Ensures variables are initialized at compile time (but can be modified later).

```cpp
constinit int global_counter = 42;  // Initialized at compile time
// global_counter can be modified later, unlike const
```

**Why**:
- Prevents static initialization order fiasco
- Guarantees zero-overhead initialization
- Avoids runtime initialization costs

**When to use**: For global/static variables that need compile-time initialization but may change during execution.

**Scenarios**:
```cpp
// 1. Global variables with guaranteed initialization
constinit int global_id = 1000;  // No runtime initialization cost
void increment_id() {
    global_id++;  // Can be modified (unlike const)
}

// 2. Static local variables
int get_next_id() {
    constinit static int counter = 0;  // Initialized once at compile time
    return ++counter;
}

// 3. Thread-local storage
constinit thread_local int thread_counter = 0;  // Each thread gets own copy

// 4. Preventing initialization order issues
// File 1:
constinit int config_value = 100;

// File 2:
extern int config_value;
constinit int derived_value = config_value * 2;  // Safe: config_value already initialized

// 5. Performance-critical globals
class Logger {
    constinit static inline int log_level = 2;  // No runtime cost
public:
    static void set_level(int level) { log_level = level; }
    static bool should_log(int level) { return level >= log_level; }
};
```

## Key Differences

| Keyword | Compile-time eval | Modifiable | Runtime callable | Use Case |
|---------|------------------|------------|------------------|----------|
| `const` | Optional | No | Yes | Immutable values |
| `constexpr` | Possible | No | Yes | Compile-time computation |
| `consteval` | Required | No | No | Immediate functions only |
| `constinit` | Required (init only) | Yes | N/A | Zero-cost initialization |

