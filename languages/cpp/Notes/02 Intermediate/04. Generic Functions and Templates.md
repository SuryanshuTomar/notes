# Generic Functions and Templates

## What are Generics?

Generics allow you to write code that works with multiple data types without sacrificing type safety. In C++, generics are implemented through **templates**.

## Function Templates

### Basic Syntax
```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}

// Usage
int result1 = add(5, 3);        // T = int
double result2 = add(2.5, 1.7); // T = double
```

### Multiple Type Parameters
```cpp
template <typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) { $SELECTION_PLACEHOLDER$
    return a * b;
}
```
-> decltype(a * b) is used to deduce the return type based on the types of `a` and `b`. This is demonstrating a **trailing return type** syntax in C++11+. Here's what each part means:

- `template <typename T, typename U>` - declares two template type parameters
- `auto multiply(T a, U b)` - function name with parameters, `auto` as placeholder return type
- `-> decltype(a * b)` - trailing return type that deduces the type of `a * b`
- The missing closing brace `}` should complete the function

The `decltype(a * b)` automatically determines the correct return type when multiplying different types (e.g., `int * double` returns `double`).

### Template Specialization
```cpp
// Primary template
template <typename T>
void print(T value) {
    std::cout << "Generic: " << value << std::endl;
}

// Specialization for const char*
template <>
void print<const char*>(const char* value) {
    std::cout << "String: " << value << std::endl;
}

int main() {
    print(42);        // Uses primary template
    print("Hello");   // Uses specialization
    return 0;
}
```

## Class Templates

### Basic Class Template
```cpp
template <typename T>
class Stack {
private:
    std::vector<T> elements;
    
public:
    void push(const T& item) {
        elements.push_back(item);
    }
    
    T pop() {
        if (elements.empty()) {
            throw std::runtime_error("Stack is empty");
        }
        T top = elements.back();
        elements.pop_back();
        return top;
    }
    
    bool empty() const {
        return elements.empty();
    }
};

// Usage
Stack<int> intStack;
Stack<std::string> stringStack;
```

### Class Template with Multiple Parameters
```cpp
template <typename Key, typename Value>
class Pair {
private:
    Key key;
    Value value;
    
public:
    Pair(const Key& k, const Value& v) : key(k), value(v) {}
    
    Key getKey() const { return key; }
    Value getValue() const { return value; }
};
```

## Method Templates

### Template Methods in Regular Classes
```cpp
class Utility {
public:
    template <typename T>
    static T max(T a, T b) {
        return (a > b) ? a : b;
    }
    
    template <typename Container>
    static void printContainer(const Container& container) {
        for (const auto& item : container) {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
};
```

### Template Methods in Template Classes
```cpp
template <typename T>
class Calculator {
public:
    template <typename U>
    auto convert(const T& value) -> U {
        return static_cast<U>(value);
    }
    
    template <typename Operation>
    T apply(const T& a, const T& b, Operation op) {
        return op(a, b);
    }
};
```

## Advanced Template Features

### Non-Type Template Parameters
```cpp
template <typename T, int Size>
class Array {
private:
    T data[Size];
    
public:
    T& operator[](int index) {
        return data[index];
    }
    
    int size() const {
        return Size;
    }
};

Array<int, 10> numbers;
```

### Template Template Parameters
```cpp
template <template <typename> class Container, typename T>
class Wrapper {
private:
    Container<T> container;
    
public:
    void add(const T& item) {
        container.push_back(item);
    }
};
```

### Variadic Templates
```cpp
template <typename... Args>
void print(Args... args) {
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}

print(1, 2.5, "hello", 'c'); // Prints: 1 2.5 hello c
```

## Best Practices

1. **Use meaningful template parameter names**
2. **Provide clear documentation for template constraints**
3. **Consider using `auto` and `decltype` for return types**
4. **Use SFINAE or concepts for template constraints**
5. **Separate declaration and definition in headers for templates**

## Example: Complete Generic Container
```cpp
template <typename T>
class Vector {
private:
    T* data;
    size_t capacity;
    size_t count;
    
public:
    Vector() : data(nullptr), capacity(0), count(0) {}
    
    ~Vector() {
        delete[] data;
    }
    
    void push_back(const T& item) {
        if (count >= capacity) {
            resize();
        }
        data[count++] = item;
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    size_t size() const { return count; }
    
private:
    void resize() {
        capacity = (capacity == 0) ? 1 : capacity * 2;
        T* newData = new T[capacity];
        for (size_t i = 0; i < count; ++i) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
    }
};
```