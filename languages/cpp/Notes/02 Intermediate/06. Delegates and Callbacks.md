# Delegates and Callbacks in C++

## What are Callbacks?
A callback is a function that is passed as an argument to another function and is executed at a specific point in the program's execution.

## Function Pointers as Callbacks

### Basic Function Pointer
```cpp
#include <iostream>

void greet() {
    std::cout << "Hello World!" << std::endl;
}

int main() {
    void (*callback)() = greet;  // Function pointer
    callback();  // Call the function through pointer
    return 0;
}
```

### Function Pointer with Parameters
```cpp
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int calculate(int x, int y, int (*operation)(int, int)) {
    return operation(x, y);
}

int main() {
    int result1 = calculate(5, 3, add);      // result1 = 8
    int result2 = calculate(5, 3, multiply); // result2 = 15
    return 0;
}
```

## std::function (Modern C++)

### Basic Usage
```cpp
#include <functional>
#include <iostream>

void processData(std::function<void()> callback) {
    std::cout << "Processing data..." << std::endl;
    callback();
}

void onComplete() {
    std::cout << "Processing complete!" << std::endl;
}

int main() {
    processData(onComplete);
    return 0;
}
```

### Lambda Functions as Callbacks
```cpp
#include <functional>
#include <vector>

void forEach(const std::vector<int>& vec, std::function<void(int)> callback) {
    for (int value : vec) {
        callback(value);
    }
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // Using lambda as callback
    forEach(numbers, [](int n) {
        std::cout << n * 2 << " ";
    });
    
    return 0;
}
```

## Event-like Delegates

### Simple Event System
```cpp
#include <vector>
#include <functional>

class EventDispatcher {
private:
    std::vector<std::function<void()>> callbacks;
    
public:
    void subscribe(std::function<void()> callback) {
        callbacks.push_back(callback);
    }
    
    void notify() {
        for (auto& callback : callbacks) {
            callback();
        }
    }
};

void onEvent1() {
    std::cout << "Event handler 1 called" << std::endl;
}

void onEvent2() {
    std::cout << "Event handler 2 called" << std::endl;
}

int main() {
    EventDispatcher dispatcher;
    
    dispatcher.subscribe(onEvent1);
    dispatcher.subscribe(onEvent2);
    dispatcher.subscribe([]() {
        std::cout << "Lambda event handler called" << std::endl;
    });
    
    dispatcher.notify();  // Calls all subscribed callbacks
    return 0;
}
```

## Member Function Callbacks

### Using std::bind
```cpp
#include <functional>
#include <iostream>

class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
    
    int subtract(int a, int b) {
        return a - b;
    }
};

int main() {
    Calculator calc;
    
    // Bind member function
    auto addCallback = std::bind(&Calculator::add, &calc, std::placeholders::_1, std::placeholders::_2);
    auto subCallback = std::bind(&Calculator::subtract, &calc, std::placeholders::_1, std::placeholders::_2);
    
    std::cout << addCallback(10, 5) << std::endl;  // 15
    std::cout << subCallback(10, 5) << std::endl;  // 5
    
    return 0;
}
```

## Common Use Cases

### Asynchronous Operations
```cpp
#include <thread>
#include <chrono>

void asyncOperation(std::function<void(bool)> onComplete) {
    std::thread([onComplete]() {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        onComplete(true);  // Simulate successful completion
    }).detach();
}

int main() {
    std::cout << "Starting async operation..." << std::endl;
    
    asyncOperation([](bool success) {
        if (success) {
            std::cout << "Operation completed successfully!" << std::endl;
        }
    });
    
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 0;
}
```

### Sorting with Custom Comparators
```cpp
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // Sort using lambda callback
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;  // Descending order
    });
    
    return 0;
}
```

## Key Points
- Function pointers are the traditional C-style callback mechanism
- `std::function` provides a more flexible, type-safe approach
- Lambda functions make inline callbacks convenient
- `std::bind` allows binding member functions and partial arguments
- Callbacks enable event-driven programming and flexible code design

---
## What are Delegates?

A delegate is a type that represents references to methods with a specific signature. In C++, delegates are typically implemented using function pointers, `std::function`, or callable objects that can hold and invoke functions or function-like objects.

## Difference Between Callbacks and Delegates

### Callbacks
- **Purpose**: A function passed to another function to be called at a specific time
- **Usage**: Primarily for event handling, asynchronous operations, and customizing behavior
- **Implementation**: Can be function pointers, lambdas, or `std::function`
- **Relationship**: One-to-one (one callback per operation)

```cpp
// Callback example - function passed to be called later
void processFile(const std::string& filename, std::function<void(bool)> callback) {
    bool success = /* file processing logic */;
    callback(success);  // Call the callback with result
}
```

### Delegates
- **Purpose**: A type that can hold references to multiple functions and invoke them
- **Usage**: Event systems, multicast notifications, and managing multiple function references
- **Implementation**: Often implemented as containers of callable objects
- **Relationship**: One-to-many (can hold multiple function references)

```cpp
template<typename... Args>
class Delegate {
private:
    std::vector<std::function<void(Args...)>> functions;
    
public:
    void operator+=(std::function<void(Args...)> func) {
        functions.push_back(func);
    }
    
    void operator()(Args... args) {
        for (auto& func : functions) {
            func(args...);
        }
    }
};

// Usage
Delegate<int> onValueChanged;
onValueChanged += [](int val) { std::cout << "Handler 1: " << val << std::endl; };
onValueChanged += [](int val) { std::cout << "Handler 2: " << val << std::endl; };
onValueChanged(42);  // Calls both handlers
```

| Aspect | Callbacks | Delegates |
|--------|-----------|-----------|
| **Invocation** | Single function call | Multiple function calls |
| **Storage** | Temporary reference | Persistent storage |
| **Use Case** | Response to events | Event broadcasting |
| **Complexity** | Simple | More complex |

### Key Differences Summary

**Callbacks:**
- Single function execution
- Passed as parameters
- Temporary usage
- Direct function invocation
- Used for customization and response handling

**Delegates:**
- Multiple function execution (multicast)
- Stored as objects
- Persistent references
- Batch invocation of all stored functions
- Used for event broadcasting and notification systems

```cpp
// Callback example - single function passed and called
void downloadFile(const std::string& url, std::function<void(bool)> onComplete) {
    // Download logic...
    onComplete(true);  // Single callback invocation
}

// Delegate example - can hold and invoke multiple functions
template<typename Signature>
class MulticastDelegate;

template<typename... Args>
class MulticastDelegate<void(Args...)> {
private:
    std::vector<std::function<void(Args...)>> handlers;
    
public:
    void add(std::function<void(Args...)> handler) {
        handlers.push_back(handler);
    }
    
    void invoke(Args... args) {
        for (auto& handler : handlers) {
            handler(args...);
        }
    }
    
    void operator+=(std::function<void(Args...)> handler) {
        add(handler);
    }
    
    void operator()(Args... args) {
        invoke(args...);
    }
};

// Usage comparison
int main() {
    // Callback usage
    downloadFile("example.com/file.zip", [](bool success) {
        std::cout << "Download " << (success ? "completed" : "failed") << std::endl;
    });
    
    // Delegate usage
    MulticastDelegate<void(int)> onScoreChanged;
    onScoreChanged += [](int score) { std::cout << "UI: Score is " << score << std::endl; };
    onScoreChanged += [](int score) { std::cout << "Audio: Play score sound" << std::endl; };
    onScoreChanged += [](int score) { std::cout << "Network: Send score update" << std::endl; };
    
    onScoreChanged(100);  // Invokes all three handlers
    
    return 0;
}
```
