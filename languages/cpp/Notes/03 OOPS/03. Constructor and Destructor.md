# Constructor and Destructor in C++

## Why Constructor and Destructor are Needed

### Purpose of Constructors
- **Automatic Initialization**: Ensures objects are properly initialized when created
- **Prevents Undefined Behavior**: Avoids accessing uninitialized variables
- **Resource Acquisition**: Allocates memory, opens files, establishes connections
- **Consistency**: Guarantees object is in valid state before use
- **Encapsulation**: Hides initialization complexity from users

### Purpose of Destructors
- **Automatic Cleanup**: Ensures resources are freed when object is destroyed
- **Memory Management**: Prevents memory leaks by deallocating dynamic memory
- **Resource Release**: Closes files, network connections, releases locks
- **Exception Safety**: Cleanup happens even if exceptions occur
- **RAII Implementation**: Resource Acquisition Is Initialization pattern

## Constructor

A constructor is a special member function that is automatically called when an object is created. It initializes the object's data members.

### Types of Constructors

#### 1. Default Constructor

**What it is**: A constructor that takes no parameters and provides default values for all data members.

**When to use**:
- When you want objects to be created with sensible default values
- When creating arrays of objects
- When using containers that require default constructible types
- When you want to allow object creation without providing initial values

**How to use**:
- Automatically called when object is declared without arguments
- Essential for creating object arrays
- Required by many STL containers

**Key points**:
- If no constructors are defined, compiler provides one
- If you define any constructor, you must explicitly define default constructor
- Can be explicitly defaulted using `= default`

```cpp
class Student {
private:
    string name;
    int age;
    vector<int> grades;
public:
    // Default constructor - provides safe initial state
    Student() {
        this->name = "Default Student";
        this->age = 18; // Default age
        cout << "Default constructor called" << endl;
    }
    
    // Compiler-generated default constructor (if no constructors defined)
    // Student() = default; // C++11 syntax to explicitly request default
    
    void display() { cout << name << ", " << age << endl; }
};

// Usage scenarios
Student s1;              // Default constructor
Student students[10];    // Array - all use default constructor
vector<Student> vec(5);  // Vector with 5 default-constructed objects
Student s2{};            // C++11 uniform initialization
```

#### 2. Inline Constructor

**What it is**: A constructor defined within the class declaration, typically for simple initialization logic.

**When to use**:
- When constructor logic is simple (1-3 lines)
- When you want to potentially improve performance through inlining
- For small classes with minimal initialization requirements
- When constructor implementation is straightforward and unlikely to change

**How to use**:
- Define constructor body directly in class declaration
- Compiler may inline the function calls for better performance
- Keep implementation simple and concise

**Key points**:
- Defined inside class definition
- Compiler decides whether to actually inline
- Good for simple initialization
- Improves code locality and readability for simple cases

```cpp
class Point2D {
private:
    int x, y;
    
public:
    // Inline default constructor
    Point2D() : x(0), y(0) {
        cout << "Point created at origin" << endl;
    }
    
    // Inline parameterized constructor
    Point2D(int xPos, int yPos) : x(xPos), y(yPos) {
        cout << "Point created at (" << x << ", " << y << ")" << endl;
    }
    
    // Inline copy constructor
    Point2D(const Point2D& other) : x(other.x), y(other.y) {
        cout << "Point copied to (" << x << ", " << y << ")" << endl;
    }
    
    void display() const { cout << "(" << x << ", " << y << ")" << endl; }
    
    // Inline getter methods
    int getX() const { return x; }
    int getY() const { return y; }
};

class Counter {
private:
    static int count;
    int id;
    
public:
    // Inline constructor with simple logic
    Counter() : id(++count) {
        cout << "Counter #" << id << " created" << endl;
    }
    
    // Inline destructor
    ~Counter() {
        cout << "Counter #" << id << " destroyed" << endl;
        --count;
    }
    
    int getId() const { return id; }
    static int getCount() { return count; }
};

int Counter::count = 0;

// Usage
Point2D origin;              // Inline default constructor
Point2D point(10, 20);       // Inline parameterized constructor
Counter c1, c2, c3;          // Multiple inline constructor calls
```

#### 3. Parameterized Constructor

**What it is**: Constructor that accepts parameters to initialize object with specific values.

**When to use**:
- When objects need specific initial values
- When default values don't make sense for your class
- When you want to enforce certain initialization requirements
- When creating objects with user-provided data

**How to use**:
- Pass arguments during object creation
- Can have multiple overloaded versions
- Use initializer lists for efficiency

**Key points**:
- More efficient than default constructor + setter methods
- Can validate input parameters
- Enables creation of immutable objects
- Can have default parameter values

```cpp
class BankAccount {
private:
    string accountNumber;
    string holderName;
    double balance;
    string accountType;
    
public:
    // Single parameter constructor
    explicit BankAccount(string accNum) 
        : accountNumber(accNum), holderName("Unknown"), balance(0.0), accountType("Savings") {
        validateAccountNumber(accNum);
    }
    
    // Multi-parameter constructor
    BankAccount(string accNum, string name, double bal) 
        : accountNumber(accNum), holderName(name), balance(bal), accountType("Savings") {
        if(bal < 0) throw invalid_argument("Balance cannot be negative");
        validateAccountNumber(accNum);
    }
    
    // Constructor with default parameters
    BankAccount(string accNum, string name, double bal = 0.0, string type = "Savings") 
        : accountNumber(accNum), holderName(name), balance(bal), accountType(type) {
        if(bal < 0) throw invalid_argument("Balance cannot be negative");
        validateAccountNumber(accNum);
    }
    
private:
    void validateAccountNumber(const string& num) {
        if(num.length() != 10) throw invalid_argument("Invalid account number");
    }
};

// Usage scenarios
BankAccount acc1("1234567890", "John Doe", 1000.0);     // Full initialization
BankAccount acc2("1234567891", "Alice");                // Uses default balance
BankAccount acc3("1234567892");                         // Uses default name and balance
```

#### 4. Copy Constructor

**What it is**: Constructor that creates a new object as a copy of an existing object.

**When to use**:
- When your class manages dynamic memory or resources
- When you need deep copying instead of shallow copying
- When passing objects by value to functions
- When returning objects by value from functions
- When initializing objects with other objects

**How to use**:
- Takes a const reference to object of same type
- Performs deep copy for pointer members
- Called automatically in specific scenarios

**Key points**:
- Essential for classes with pointer members.
- Prevents shallow copy problems.
- Called implicitly in many situations.
- Should perform deep copy for resource management.
- Copy constructor is not called for assignment (use copy assignment operator for that).
- Copy constructor default behavior is shallow copy, which can lead to issues with dynamic memory.
- Default copy constructor does not work when class has pointers or resources that need deep copying.

```cpp
class DynamicArray {
private:
    int* data;
    int size;
    int capacity;
    
public:
    DynamicArray(int cap) : size(0), capacity(cap) {
        data = new int[capacity];
        cout << "Constructor: Created array with capacity " << capacity << endl;
    }
    
    // Copy constructor - performs deep copy - allocates new memory
    // as opposed to shallow copy also, default constructor would not work here because of dynamic memory allocation of `data`
    // here we are also passing the `other` object as a reference because we don't want to copy the object itself as it would lead to infinite recursion of copy constructor calls.
    // But we can also pass this as value, and provide a default constructor that initializes the `data` pointer to `nullptr`.
    // This is important to avoid shallow copy issues with dynamic memory.
    DynamicArray(const DynamicArray& other) 
        : size(other.size), capacity(other.capacity) {
        data = new int[capacity];  // Allocate new memory
        
        // Copy all elements
        for(int i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
        cout << "Copy constructor: Deep copied array" << endl;
    }
    
    ~DynamicArray() { 
        delete[] data; 
        cout << "Destructor: Freed array memory" << endl;
    }
    
    void add(int value) {
        if(size < capacity) data[size++] = value;
    }
    
    void display() const {
        for(int i = 0; i < size; i++) cout << data[i] << " ";
        cout << endl;
    }
};

// When copy constructor is called:
void processArray(DynamicArray arr) {  // Pass by value - copy constructor called
    arr.add(100);
    arr.display();
}

DynamicArray createArray() {
    DynamicArray temp(5);
    temp.add(10);
    return temp;  // Copy constructor might be called (or optimized away)
}

// Usage
DynamicArray arr1(5);
arr1.add(1); arr1.add(2);

DynamicArray arr2(arr1);            // Copy constructor
DynamicArray arr3 = arr1;           // Copy constructor (not assignment), 
                                    // as here we are initializing a new object with an existing one
arr2 = arr1;                        // Copy assignment operator (not Copy constructor)
processArray(arr1);                 // Copy constructor for parameter
DynamicArray arr4 = createArray(); // Copy constructor for return value
```

#### 5. Move Constructor (C++11)

**What it is**: Constructor that transfers resources from a temporary object instead of copying them.

**When to use**:
- When working with temporary objects
- When you want to optimize performance by avoiding unnecessary copies
- When dealing with expensive-to-copy resources
- When implementing efficient container operations

**How to use**:
- Takes an rvalue reference (&&) to object of same type
- Transfers ownership of resources
- Leaves source object in valid but empty state

**Key points**:
- Significantly improves performance for resource-heavy classes
- Automatically called for temporary objects
- Should be marked noexcept for optimal container performance
- Part of move semantics in modern C++

```cpp
class LargeResource {
private:
    int* data;
    int size;
    string resourceName;
    
public:
    // Constructor
    LargeResource(int s, string name) : size(s), resourceName(name) {
        data = new int[size];
        // Simulate expensive initialization
        for(int i = 0; i < size; i++) data[i] = i;
        cout << "Created resource: " << resourceName << " (size: " << size << ")" << endl;
    }
    
    // Move constructor - transfers ownership
    LargeResource(LargeResource&& other) noexcept 
        : data(other.data), size(other.size), resourceName(std::move(other.resourceName)) {
        
        // Leave other in valid but empty state
        other.data = nullptr;
        other.size = 0;
        other.resourceName.clear();
        
        cout << "Move constructor: Transferred resource ownership" << endl;
    }
    
    // Copy constructor for comparison
    LargeResource(const LargeResource& other) 
        : size(other.size), resourceName(other.resourceName + "_copy") {
        data = new int[size];
        copy_n(other.data, size, data);  // Expensive copy operation
        cout << "Copy constructor: Expensive copy operation" << endl;
    }
    
    ~LargeResource() { 
        if(data) {
            delete[] data; 
            cout << "Destroyed resource: " << resourceName << endl;
        }
    }
    
    void display() const {
        cout << "Resource: " << resourceName << " (size: " << size << ")" << endl;
    }
};

LargeResource createResource(int size) {
    return LargeResource(size, "TempResource");  // Move constructor used
}

// Usage
LargeResource res1 = createResource(1000);      // Move constructor
LargeResource res2 = std::move(res1);           // Explicit move
vector<LargeResource> vec;
vec.push_back(createResource(500));             // Move into container
```

#### 6. Delegating Constructor (C++11)

**What it is**: Constructor that calls another constructor of the same class to avoid code duplication.

**When to use**:
- When multiple constructors share common initialization logic
- When you want to centralize validation or setup code
- When creating constructor overloads with default parameters
- When implementing constructor hierarchies within a class

**How to use**:
- Use member initializer list to call another constructor
- Target constructor executes completely before delegating constructor body
- Cannot initialize members and delegate simultaneously

**Key points**:
- Reduces code duplication
- Improves maintainability
- Centralizes initialization logic
- Can create constructor chains

```cpp
class Rectangle {
private:
    int length, width;
    string name;
    bool isValid;
    
public:
    // Primary constructor with full validation
    Rectangle(int l, int w, string n) : length(l), width(w), name(n) {
        validateDimensions();
        cout << "Primary constructor: " << name << " (" << length << "x" << width << ")" << endl;
    }
    
    // Delegating constructors - call primary constructor
    Rectangle() : Rectangle(1, 1, "DefaultRectangle") {
        cout << "Default constructor delegating" << endl;
    }
    
    Rectangle(int side) : Rectangle(side, side, "Square") {
        cout << "Square constructor delegating" << endl;
    }
    
    Rectangle(int l, int w) : Rectangle(l, w, "UnnamedRectangle") {
        cout << "Unnamed rectangle constructor delegating" << endl;
    }
    
    // Copy constructor can also delegate
    Rectangle(const Rectangle& other) : Rectangle(other.length, other.width, other.name + "_copy") {
        cout << "Copy constructor delegating" << endl;
    }
    
private:
    void validateDimensions() {
        if(length <= 0 || width <= 0) {
            throw invalid_argument("Dimensions must be positive");
        }
        isValid = true;
    }
    
public:
    void display() const {
        cout << name << ": " << length << " x " << width 
             << " (Area: " << length * width << ")" << endl;
    }
};

// Usage scenarios
Rectangle r1;                    // Default -> Primary constructor
Rectangle r2(5);                 // Square -> Primary constructor
Rectangle r3(3, 4);              // Unnamed -> Primary constructor
Rectangle r4(2, 6, "MyRect");    // Direct primary constructor call
Rectangle r5(r4);                // Copy -> Primary constructor
```

#### 7. Explicit Constructor

**What it is**: Constructor marked with `explicit` keyword to prevent implicit type conversions.

**When to use**:
- When you want to prevent accidental type conversions
- For single-parameter constructors that shouldn't allow implicit conversion
- When type safety is more important than convenience
- When designing APIs that should be explicit about object creation

**How to use**:
- Add `explicit` keyword before constructor declaration
- Only allows explicit construction, not implicit conversion
- Prevents assignment-style initialization

**Key points**:
- Prevents subtle bugs from unintended conversions
- Makes code more readable and intentional
- Required for constructors that take single parameters in many style guides
- Can be used with multi-parameter constructors too

```cpp
class Temperature {
private:
    double celsius;
    
public:
    // Explicit constructor prevents implicit conversions
    explicit Temperature(double c) : celsius(c) {
        if(c < -273.15) throw invalid_argument("Temperature below absolute zero");
        cout << "Temperature created: " << celsius << "°C" << endl;
    }
    
    // Non-explicit constructor for demonstration
    // Temperature(double c) : celsius(c) {}  // Would allow implicit conversion
    
    double getCelsius() const { return celsius; }
    double getFahrenheit() const { return celsius * 9.0/5.0 + 32; }
    
    void display() const {
        cout << celsius << "°C (" << getFahrenheit() << "°F)" << endl;
    }
};

void processTemperature(const Temperature& temp) {
    temp.display();
}

class SafeArray {
private:
    vector<int> data;
    
public:
    // Explicit constructor prevents accidental conversion from int to SafeArray
    explicit SafeArray(int size) : data(size, 0) {
        if(size < 0) throw invalid_argument("Size cannot be negative");
        cout << "SafeArray created with size: " << size << endl;
    }
    
    SafeArray(initializer_list<int> values) : data(values) {
        cout << "SafeArray created with initializer list" << endl;
    }
    
    int& operator[](int index) { return data[index]; }
    int size() const { return data.size(); }
};

// Usage and comparison
Temperature temp1(25.0);              // OK: Explicit construction
Temperature temp2 = Temperature(30.0); // OK: Explicit construction
// Temperature temp3 = 35.0;          // Error: Implicit conversion not allowed
// processTemperature(40.0);          // Error: Cannot implicitly convert double to Temperature

SafeArray arr1(10);                   // OK: Explicit construction
SafeArray arr2 = SafeArray(5);        // OK: Explicit construction
SafeArray arr3{1, 2, 3, 4, 5};       // OK: Initializer list constructor
// SafeArray arr4 = 8;               // Error: Implicit conversion not allowed

// Function that might accidentally accept wrong type without explicit
void processArray(const SafeArray& arr) {
    cout << "Processing array of size: " << arr.size() << endl;
}

// processArray(15);  // Would be error with explicit constructor
                      // Without explicit, this would create SafeArray(15) implicitly
```

## Destructor

A destructor is a special member function that is automatically called when an object goes out of scope or is explicitly deleted.

### Destructor Characteristics

#### 1. Basic Destructor

**What it is**: Special member function that cleans up resources when object is destroyed.

**When to use**:
- When your class allocates dynamic memory
- When managing file handles, network connections, or other resources
- When you need to perform cleanup operations
- When implementing RAII pattern

**How to use**:
- Automatically called when object goes out of scope
- Can be called explicitly with delete for dynamic objects
- Should clean up all resources acquired by the object

**Key points**:
- No parameters and no return type
- Cannot be overloaded
- Should not throw exceptions
- Essential for preventing resource leaks

```cpp
class FileManager {
private:
    string* filename;
    FILE* fileHandle;
    char* buffer;
    int bufferSize;
    
public:
    FileManager(const string& fname, int bufSize = 1024) : bufferSize(bufSize) {
        filename = new string(fname);
        buffer = new char[bufferSize];
        fileHandle = fopen(fname.c_str(), "r");
        
        if(!fileHandle) {
            delete filename;
            delete[] buffer;
            throw runtime_error("Cannot open file: " + fname);
        }
        
        cout << "FileManager created for: " << *filename << endl;
    }
    
    // Destructor - cleans up all resources
    ~FileManager() {
        cout << "Destructor called for: " << (filename ? *filename : "unknown") << endl;
        
        // Clean up in reverse order of acquisition
        if(fileHandle) {
            fclose(fileHandle);
            cout << "File handle closed" << endl;
        }
        
        if(buffer) {
            delete[] buffer;
            cout << "Buffer freed" << endl;
        }
        
        if(filename) {
            delete filename;
            cout << "Filename freed" << endl;
        }
    }
    
    bool readLine(string& line) {
        if(!fileHandle) return false;
        if(fgets(buffer, bufferSize, fileHandle)) {
            line = buffer;
            return true;
        }
        return false;
    }
};

// Usage - automatic cleanup
{
    FileManager fm("data.txt");
    string line;
    while(fm.readLine(line)) {
        cout << line;
    }
    // Destructor automatically called here when fm goes out of scope
}
```

#### 2. Virtual Destructor

**What it is**: Destructor marked as virtual to ensure proper cleanup in inheritance hierarchies.

**When to use**:
- When your class is intended to be a base class
- When using polymorphism with base class pointers
- When derived classes have their own resources to clean up
- When implementing interfaces or abstract classes

**How to use**:
- Mark base class destructor as virtual
- Override in derived classes as needed
- Ensures proper destruction order in polymorphic scenarios

**Key points**:
- Essential for polymorphic base classes
- Prevents resource leaks in inheritance hierarchies
- Ensures derived destructors are called
- Should be virtual if any function is virtual

```cpp
class Shape {
protected:
    string* shapeName;
    
public:
    Shape(const string& name) : shapeName(new string(name)) {
        cout << "Shape constructor: " << *shapeName << endl;
    }
    
    // Virtual destructor enables proper polymorphic destruction
    virtual ~Shape() {
        cout << "Shape destructor: " << (shapeName ? *shapeName : "unknown") << endl;
        delete shapeName;
    }
    
    virtual void draw() = 0;  // Pure virtual function
    virtual double area() = 0;
};

class Circle : public Shape {
private:
    double* radius;
    static int circleCount;
    
public:
    Circle(double r) : Shape("Circle"), radius(new double(r)) {
        circleCount++;
        cout << "Circle constructor: radius = " << *radius 
             << " (Total circles: " << circleCount << ")" << endl;
    }
    
    // Override virtual destructor
    ~Circle() override {
        cout << "Circle destructor: radius = " << (radius ? *radius : 0) << endl;
        delete radius;
        circleCount--;
        cout << "Remaining circles: " << circleCount << endl;
        // Base class destructor called automatically after this
    }
    
    void draw() override {
        cout << "Drawing circle with radius " << *radius << endl;
    }
    
    double area() override {
        return 3.14159 * (*radius) * (*radius);
    }
};

int Circle::circleCount = 0;

class Rectangle : public Shape {
private:
    double* width;
    double* height;
    
public:
    Rectangle(double w, double h) : Shape("Rectangle"), 
                                   width(new double(w)), height(new double(h)) {
        cout << "Rectangle constructor: " << *width << "x" << *height << endl;
    }
    
    ~Rectangle() override {
        cout << "Rectangle destructor: " << (width ? *width : 0) 
             << "x" << (height ? *height : 0) << endl;
        delete width;
        delete height;
    }
    
    void draw() override {
        cout << "Drawing rectangle " << *width << "x" << *height << endl;
    }
    
    double area() override {
        return (*width) * (*height);
    }
};

// Demonstration of virtual destructor importance
void processShapes() {
    vector<Shape*> shapes;
    
    shapes.push_back(new Circle(5.0));
    shapes.push_back(new Rectangle(3.0, 4.0));
    shapes.push_back(new Circle(2.5));
    
    // Use polymorphism
    for(Shape* shape : shapes) {
        shape->draw();
        cout << "Area: " << shape->area() << endl;
    }
    
    // Clean up - virtual destructors ensure proper cleanup
    for(Shape* shape : shapes) {
        delete shape;  // Calls appropriate derived destructor first, then base
    }
}
```

#### 3. Destructor Order

**What it is**: The specific sequence in which destructors are called for objects and their members.

**When to use this knowledge**:
- When designing classes with complex member relationships
- When managing interdependent resources
- When debugging destruction-related issues
- When ensuring proper cleanup order

**How it works**:
- Destructor body executes first
- Member objects destroyed in reverse order of declaration
- Base class destructors called after derived class destructors

**Key points**:
- Destruction is reverse of construction
- Member destructors called automatically
- Important for managing dependencies between resources

```cpp
class Logger {
private:
    string loggerName;
    
public:
    Logger(const string& name) : loggerName(name) {
        cout << "Logger created: " << loggerName << endl;
    }
    
    ~Logger() {
        cout << "Logger destroyed: " << loggerName << endl;
    }
    
    void log(const string& message) {
        cout << "[" << loggerName << "] " << message << endl;
    }
};

class Database {
private:
    string dbName;
    
public:
    Database(const string& name) : dbName(name) {
        cout << "Database connected: " << dbName << endl;
    }
    
    ~Database() {
        cout << "Database disconnected: " << dbName << endl;
    }
    
    void query(const string& sql) {
        cout << "Executing on " << dbName << ": " << sql << endl;
    }
};

class Application {
private:
    Logger logger;        // Declared first
    Database database;    // Declared second
    string* appName;      // Declared third
    
public:
    Application(const string& name) 
        : logger("AppLogger"),           // Constructed first
          database("MainDB"),            // Constructed second  
          appName(new string(name)) {    // Constructed third
        cout << "Application created: " << *appName << endl;
        logger.log("Application started");
    }
    
    ~Application() {
        cout << "Application destructor body executing for: " 
             << (appName ? *appName : "unknown") << endl;
        
        if(appName) {
            logger.log("Application shutting down");
            delete appName;  // Manual cleanup
        }
        
        // After this point, automatic member destruction occurs:
        // 1. appName (already manually deleted)
        // 2. database destructor (declared last, destroyed first)
        // 3. logger destructor (declared first, destroyed last)
    }
    
    void run() {
        logger.log("Application running");
        database.query("SELECT * FROM users");
    }
};

// Usage demonstrating destruction order
void demonstrateDestructionOrder() {
    cout << "=== Creating Application ===" << endl;
    {
        Application app("MyApp");
        app.run();
        cout << "=== About to leave scope ===" << endl;
    }
    cout << "=== Application destroyed ===" << endl;
}

// Expected output:
// Logger created: AppLogger
// Database connected: MainDB  
// Application created: MyApp
// [AppLogger] Application started
// [AppLogger] Application running
// Executing on MainDB: SELECT * FROM users
// === About to leave scope ===
// Application destructor body executing for: MyApp
// [AppLogger] Application shutting down
// Database disconnected: MainDB
// Logger destroyed: AppLogger
// === Application destroyed ===
```

## Advanced Constructor Concepts

### Constructor Inheritance (C++11)
```cpp
class Base {
public:
    Base(int x, string s) {}
    Base(double d) {}
};

class Derived : public Base {
public:
    using Base::Base;  // Inherit all Base constructors
    
    // Additional constructor
    Derived(char c) : Base(static_cast<int>(c), "char") {}
};
```

### Aggregate Initialization
```cpp
struct Point {
    int x, y;
    // No user-defined constructors = aggregate
};

Point p1{10, 20};        // Aggregate initialization
Point p2 = {30, 40};     // Also aggregate initialization
```

## Complete Example with Resource Management

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class SmartArray {
private:
    unique_ptr<int[]> arr;
    int size;
    static int objectCount;
    
public:
    // Default constructor
    SmartArray() : arr(nullptr), size(0) {
        ++objectCount;
        cout << "Default constructor. Objects: " << objectCount << endl;
    }
    
    // Parameterized constructor
    explicit SmartArray(int s) : size(s) {
        arr = make_unique<int[]>(size);
        fill_n(arr.get(), size, 0);
        ++objectCount;
        cout << "Parameterized constructor for size " << size 
             << ". Objects: " << objectCount << endl;
    }
    
    // Copy constructor (Deep copy)
    SmartArray(const SmartArray& other) : size(other.size) {
        if(other.arr) {
            arr = make_unique<int[]>(size);
            copy_n(other.arr.get(), size, arr.get());
        }
        ++objectCount;
        cout << "Copy constructor. Objects: " << objectCount << endl;
    }
    
    // Move constructor
    SmartArray(SmartArray&& other) noexcept 
        : arr(std::move(other.arr)), size(other.size) {
        other.size = 0;
        ++objectCount;
        cout << "Move constructor. Objects: " << objectCount << endl;
    }
    
    // Destructor
    ~SmartArray() {
        --objectCount;
        cout << "Destructor called. Remaining objects: " << objectCount << endl;
        // unique_ptr automatically deallocates memory
    }
    
    void setValue(int index, int value) {
        if(arr && index >= 0 && index < size) {
            arr[index] = value;
        }
    }
    
    void display() const {
        if(arr) {
            for(int i = 0; i < size; i++) {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    }
};

int SmartArray::objectCount = 0;

int main() {
    {
        SmartArray arr1(5);        // Parameterized constructor
        arr1.setValue(0, 10);
        arr1.setValue(1, 20);
        
        SmartArray arr2 = arr1;    // Copy constructor
        arr2.display();
        
        SmartArray arr3 = std::move(arr1);  // Move constructor
        
        // All destructors called when leaving scope
    }
    
    cout << "All objects destroyed" << endl;
    return 0;
}
```

## Key Points

### Constructor Points
- **No return type**: Not even void
- **Same name as class**: Exact match required
- **Can be overloaded**: Multiple constructors with different parameters
- **Automatic invocation**: Called automatically when object is created
- **Initializer lists**: Preferred for initialization (more efficient)
- **Member initialization order**: Follows declaration order in class
- **Cannot be virtual**: Objects don't exist during construction
- **Can call other constructors**: Delegating constructors (C++11)

### Destructor Points
- **Prefixed with ~**: Tilde symbol before class name
- **No parameters**: Cannot be overloaded
- **No return type**: Not even void
- **Automatic invocation**: Called when object goes out of scope
- **Virtual destructors**: Essential for polymorphic base classes
- **Cleanup order**: Reverse order of construction
- **Exception safety**: Should not throw exceptions
- **RAII compliance**: Resource cleanup guaranteed

## Best Practices

### Constructor Best Practices
1. **Use initializer lists**: More efficient than assignment in constructor body
2. **Mark single-parameter constructors explicit**: Prevent unwanted implicit conversions
3. **Provide default constructor**: If other constructors are defined
4. **Initialize all members**: Avoid undefined behavior
5. **Use delegating constructors**: Reduce code duplication
6. **Validate parameters**: Ensure object is in valid state

### Destructor Best Practices
1. **Virtual destructors for base classes**: Enable proper cleanup in inheritance
2. **No exceptions in destructors**: Mark as noexcept when possible
3. **RAII pattern**: Acquire resources in constructor, release in destructor
4. **Rule of Five**: If you need destructor, consider copy/move constructors and assignment operators
5. **Smart pointers**: Prefer automatic memory management
6. **Exception safety**: Ensure cleanup happens even with exceptions

## Rule of Three/Five/Zero

- **Rule of Three**: If you need destructor, copy constructor, or copy assignment operator, you likely need all three
- **Rule of Five**: Add move constructor and move assignment operator (C++11)
- **Rule of Zero**: Prefer using smart pointers and RAII to avoid manual resource management