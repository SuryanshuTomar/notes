# Exception Handling in C++

## Table of Contents
1. [What are Exceptions?](#what-are-exceptions)
2. [Types of Exceptions in C++](#types-of-exceptions-in-c)
3. [Exception Handling Mechanisms](#exception-handling-mechanisms)
4. [Handling Specific Exceptions](#handling-specific-exceptions)
5. [Custom Exceptions](#custom-exceptions)
6. [Best Practices](#best-practices)

---

## What are Exceptions?

**Exception** is an abnormal condition or error that occurs during program execution. When an exception occurs, it disrupts the normal flow of the program and needs to be handled properly to prevent the program from crashing.

### Key Characteristics:
- Exceptions are runtime errors, not compile-time errors
- They can be thrown (raised) and caught (handled)
- If not handled, they terminate the program
- They provide a way to transfer control from one part of a program to another

### Why Use Exceptions?
- **Error Handling**: Separate error handling code from normal program logic
- **Propagation**: Errors can be handled at the appropriate level in the call stack
- **Clean Code**: Makes code more readable by separating normal flow from error handling
- **Resource Management**: Ensures proper cleanup even when errors occur

---

## Types of Exceptions in C++

C++ provides several built-in exception types, all derived from the `std::exception` class.

### 1. **std::exception** (Base Class)
- Root of all standard exceptions
- Provides virtual `what()` method that returns error description

```cpp
#include <exception>
#include <iostream>

try {
    throw std::exception();
} catch (const std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
```

### 2. **std::runtime_error**
Exceptions that can only be detected during runtime.

#### **std::overflow_error**
- **What**: Arithmetic overflow error
- **When**: Result of arithmetic operation is too large to be represented
- **Example**: Integer overflow, floating-point overflow

```cpp
#include <stdexcept>
#include <limits>

int a = std::numeric_limits<int>::max();
// This could cause overflow
if (a == std::numeric_limits<int>::max()) {
    throw std::overflow_error("Integer overflow detected");
}
```

#### **std::underflow_error**
- **What**: Arithmetic underflow error
- **When**: Result of arithmetic operation is too small to be represented
- **Example**: Floating-point underflow

```cpp
#include <stdexcept>

double very_small = 1e-400;
if (very_small == 0.0) {
    throw std::underflow_error("Floating-point underflow");
}
```

#### **std::range_error**
- **What**: Error when result is not in the expected range
- **When**: Mathematical functions return values outside valid range
- **Example**: Domain errors in mathematical operations

```cpp
#include <stdexcept>
#include <cmath>

double x = -1.0;
if (x < 0) {
    throw std::range_error("Cannot compute square root of negative number");
}
```

### 3. **std::logic_error**
Exceptions that represent errors in program logic (theoretically preventable).

#### **std::invalid_argument**
- **What**: Invalid argument passed to function
- **When**: Function receives argument outside acceptable range
- **Example**: Invalid parameters to constructors or functions

```cpp
#include <stdexcept>

void setAge(int age) {
    if (age < 0 || age > 150) {
        throw std::invalid_argument("Age must be between 0 and 150");
    }
}
```

#### **std::domain_error**
- **What**: Mathematical domain error
- **When**: Argument is outside the domain of mathematical function
- **Example**: Square root of negative number, logarithm of negative number

```cpp
#include <stdexcept>
#include <cmath>

double safeSqrt(double x) {
    if (x < 0) {
        throw std::domain_error("Cannot compute square root of negative number");
    }
    return sqrt(x);
}
```

#### **std::length_error**
- **What**: Object length exceeds maximum allowed size
- **When**: Trying to create objects larger than maximum size
- **Example**: Vector resize beyond max_size()

```cpp
#include <stdexcept>
#include <vector>

std::vector<int> vec;
try {
    vec.resize(vec.max_size() + 1);
} catch (const std::length_error& e) {
    std::cout << "Length error: " << e.what() << std::endl;
}
```

#### **std::out_of_range**
- **What**: Access to elements outside valid range
- **When**: Index is outside container bounds
- **Example**: Vector at(), string at(), array access

```cpp
#include <stdexcept>
#include <vector>

std::vector<int> vec = {1, 2, 3};
try {
    int value = vec.at(10);  // Index 10 doesn't exist
} catch (const std::out_of_range& e) {
    std::cout << "Out of range: " << e.what() << std::endl;
}
```

### 4. **std::bad_alloc**
- **What**: Memory allocation failure
- **When**: `new` operator fails to allocate memory
- **Example**: Insufficient memory available

```cpp
#include <new>
#include <iostream>

try {
    int* huge_array = new int[1000000000000];  // Very large allocation
} catch (const std::bad_alloc& e) {
    std::cout << "Memory allocation failed: " << e.what() << std::endl;
}
```

### 5. **std::bad_cast**
- **What**: Invalid type cast
- **When**: `dynamic_cast` fails on reference types
- **Example**: Casting to incompatible type

```cpp
#include <typeinfo>

class Base { virtual ~Base() {} };
class Derived : public Base {};
class Other {};

Base* base = new Base();
try {
    Derived& derived = dynamic_cast<Derived&>(*base);
} catch (const std::bad_cast& e) {
    std::cout << "Bad cast: " << e.what() << std::endl;
}
```

### 6. **std::bad_typeid**
- **What**: Invalid use of typeid
- **When**: `typeid` applied to null pointer of polymorphic type
- **Example**: typeid on null pointer

```cpp
#include <typeinfo>

class Base { virtual ~Base() {} };

Base* ptr = nullptr;
try {
    const std::type_info& info = typeid(*ptr);  // Dereferencing null
} catch (const std::bad_typeid& e) {
    std::cout << "Bad typeid: " << e.what() << std::endl;
}
```

---

## Exception Handling Mechanisms

### 1. **try-catch Block**
Basic syntax for handling exceptions:

```cpp
try {
    // Code that might throw an exception
    risky_operation();
} catch (const SpecificException& e) {
    // Handle specific exception
    std::cout << "Specific error: " << e.what() << std::endl;
} catch (const std::exception& e) {
    // Handle any standard exception
    std::cout << "General error: " << e.what() << std::endl;
} catch (...) {
    // Handle any other exception
    std::cout << "Unknown error occurred" << std::endl;
}
```

### 2. **throw Statement**
Used to explicitly throw an exception:

```cpp
void validateInput(int value) {
    if (value < 0) {
        throw std::invalid_argument("Value cannot be negative");
    }
    if (value > 100) {
        throw std::out_of_range("Value exceeds maximum limit");
    }
}
```

### 3. **Exception Propagation**
If an exception is not caught in the current function, it propagates up the call stack:

```cpp
void level3() {
    throw std::runtime_error("Error in level 3");
}

void level2() {
    level3();  // Exception propagates from here
}

void level1() {
    try {
        level2();
    } catch (const std::runtime_error& e) {
        std::cout << "Caught at level 1: " << e.what() << std::endl;
    }
}
```

### 4. **RAII and Exception Safety**
Resource Acquisition Is Initialization ensures proper cleanup:

```cpp
class ResourceManager {
private:
    int* resource;
public:
    ResourceManager() : resource(new int[100]) {}
    ~ResourceManager() { delete[] resource; }  // Automatic cleanup
    
    void riskyOperation() {
        if (/* some condition */) {
            throw std::runtime_error("Operation failed");
        }
        // Resource automatically cleaned up even if exception thrown
    }
};
```

---

## Handling Specific Exceptions

### Memory-Related Exceptions

```cpp
#include <new>
#include <iostream>

void handleMemoryExceptions() {
    try {
        // Try to allocate large amount of memory
        size_t huge_size = 1000000000000;
        int* ptr = new int[huge_size];
        delete[] ptr;
    } catch (const std::bad_alloc& e) {
        std::cout << "Memory allocation failed: " << e.what() << std::endl;
        // Handle by using alternative approach or cleaning up
    }
}
```

### Container Access Exceptions

```cpp
#include <vector>
#include <stdexcept>
#include <iostream>

void handleContainerExceptions() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    try {
        // Safe access with exception handling
        int value = vec.at(10);  // Will throw std::out_of_range
    } catch (const std::out_of_range& e) {
        std::cout << "Index out of range: " << e.what() << std::endl;
        // Handle by using default value or asking for valid index
        std::cout << "Using default value instead" << std::endl;
    }
}
```

### Mathematical Exceptions

```cpp
#include <stdexcept>
#include <cmath>
#include <iostream>

double safeDivide(double a, double b) {
    if (b == 0.0) {
        throw std::invalid_argument("Division by zero");
    }
    return a / b;
}

double safeLogarithm(double x) {
    if (x <= 0) {
        throw std::domain_error("Logarithm of non-positive number");
    }
    return log(x);
}

void handleMathExceptions() {
    try {
        double result1 = safeDivide(10.0, 0.0);
        double result2 = safeLogarithm(-5.0);
    } catch (const std::invalid_argument& e) {
        std::cout << "Invalid argument: " << e.what() << std::endl;
    } catch (const std::domain_error& e) {
        std::cout << "Domain error: " << e.what() << std::endl;
    }
}
```

---

## Custom Exceptions

### 1. **Inheriting from std::exception**

```cpp
#include <exception>
#include <string>

class CustomException : public std::exception {
private:
    std::string message;
    
public:
    explicit CustomException(const std::string& msg) : message(msg) {}
    
    virtual const char* what() const noexcept override {
        return message.c_str();
    }
};

// Usage
void someFunction() {
    throw CustomException("This is a custom error message");
}
```

### 2. **Inheriting from Specific Exception Types**

```cpp
#include <stdexcept>

class InvalidEmailException : public std::invalid_argument {
public:
    explicit InvalidEmailException(const std::string& email) 
        : std::invalid_argument("Invalid email format: " + email) {}
};

class DatabaseConnectionException : public std::runtime_error {
public:
    explicit DatabaseConnectionException(const std::string& details)
        : std::runtime_error("Database connection failed: " + details) {}
};

// Usage
void validateEmail(const std::string& email) {
    if (email.find('@') == std::string::npos) {
        throw InvalidEmailException(email);
    }
}
```

### 3. **Complex Custom Exception with Additional Information**

```cpp
#include <exception>
#include <string>

class FileException : public std::exception {
private:
    std::string filename;
    std::string operation;
    int error_code;
    std::string message;
    
public:
    FileException(const std::string& file, const std::string& op, int code)
        : filename(file), operation(op), error_code(code) {
        message = "File operation '" + operation + "' failed on '" + 
                  filename + "' with error code " + std::to_string(error_code);
    }
    
    virtual const char* what() const noexcept override {
        return message.c_str();
    }
    
    const std::string& getFilename() const { return filename; }
    const std::string& getOperation() const { return operation; }
    int getErrorCode() const { return error_code; }
};

// Usage
void readFile(const std::string& filename) {
    // Simulate file operation failure
    if (/* file doesn't exist */) {
        throw FileException(filename, "read", 404);
    }
}

void handleFileOperations() {
    try {
        readFile("nonexistent.txt");
    } catch (const FileException& e) {
        std::cout << "File error: " << e.what() << std::endl;
        std::cout << "File: " << e.getFilename() << std::endl;
        std::cout << "Operation: " << e.getOperation() << std::endl;
        std::cout << "Error code: " << e.getErrorCode() << std::endl;
    }
}
```

### 4. **Exception Hierarchy for Different Error Types**

```cpp
// Base exception for application
class AppException : public std::exception {
protected:
    std::string message;
    
public:
    explicit AppException(const std::string& msg) : message(msg) {}
    virtual const char* what() const noexcept override {
        return message.c_str();
    }
};

// Network-related exceptions
class NetworkException : public AppException {
public:
    explicit NetworkException(const std::string& msg) 
        : AppException("Network Error: " + msg) {}
};

class ConnectionTimeoutException : public NetworkException {
public:
    ConnectionTimeoutException() 
        : NetworkException("Connection timed out") {}
};

class InvalidUrlException : public NetworkException {
public:
    explicit InvalidUrlException(const std::string& url)
        : NetworkException("Invalid URL: " + url) {}
};

// Usage with multiple catch blocks
void networkOperation() {
    try {
        // Some network operation
        throw ConnectionTimeoutException();
    } catch (const ConnectionTimeoutException& e) {
        // Handle timeout specifically
        std::cout << "Timeout error: " << e.what() << std::endl;
        // Maybe retry logic here
    } catch (const NetworkException& e) {
        // Handle other network errors
        std::cout << "Network error: " << e.what() << std::endl;
    } catch (const AppException& e) {
        // Handle any application error
        std::cout << "Application error: " << e.what() << std::endl;
    }
}
```

---

## Best Practices

### 1. **Exception Safety Levels**

```cpp
// Basic guarantee: No resource leaks, object remains in valid state
class BasicSafety {
    std::vector<int> data;
public:
    void riskyOperation() {
        try {
            data.push_back(getValue());  // May throw
        } catch (...) {
            // data is still in valid state
            throw;
        }
    }
};

// Strong guarantee: Operation either succeeds completely or has no effect
class StrongSafety {
    std::vector<int> data;
public:
    void riskyOperation() {
        std::vector<int> temp = data;  // Copy current state
        try {
            temp.push_back(getValue());  // May throw
            data = std::move(temp);      // Only modify if successful
        } catch (...) {
            // data unchanged if exception thrown
            throw;
        }
    }
};
```

### 2. **RAII Pattern**

```cpp
class FileHandler {
private:
    FILE* file;
    
public:
    explicit FileHandler(const std::string& filename) {
        file = fopen(filename.c_str(), "r");
        if (!file) {
            throw FileException(filename, "open", errno);
        }
    }
    
    ~FileHandler() {
        if (file) {
            fclose(file);
        }
    }
    
    // Disable copy to prevent double-close
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    // Enable move
    FileHandler(FileHandler&& other) noexcept : file(other.file) {
        other.file = nullptr;
    }
};
```

### 3. **Exception Specifications (C++11 and later)**

```cpp
// Function that doesn't throw exceptions
void noThrowFunction() noexcept {
    // This function promises not to throw
}

// Function that may throw
void mayThrowFunction() {
    throw std::runtime_error("Something went wrong");
}

// Conditional noexcept
template<typename T>
void conditionalNoThrow() noexcept(std::is_nothrow_constructible_v<T>) {
    T obj;
}
```

### 4. **General Guidelines**

- **Catch by const reference**: `catch (const std::exception& e)`
- **Use specific exception types**: Don't just throw `std::exception`
- **Don't throw in destructors**: Can cause program termination
- **Use RAII**: Ensure resources are properly cleaned up
- **Consider exception safety**: Design functions with exception safety in mind
- **Document exceptions**: Specify what exceptions your functions can throw
- **Don't catch and ignore**: Always handle exceptions appropriately

```cpp
// Good exception handling example
class BankAccount {
private:
    double balance;
    
public:
    explicit BankAccount(double initial_balance) : balance(initial_balance) {
        if (initial_balance < 0) {
            throw std::invalid_argument("Initial balance cannot be negative");
        }
    }
    
    void withdraw(double amount) {
        if (amount < 0) {
            throw std::invalid_argument("Withdrawal amount cannot be negative");
        }
        if (amount > balance) {
            throw std::runtime_error("Insufficient funds");
        }
        balance -= amount;  // Only modify if all checks pass
    }
    
    double getBalance() const noexcept {
        return balance;
    }
};
```

This comprehensive guide covers all aspects of exception handling in C++, from basic concepts to advanced custom exception design and best practices.