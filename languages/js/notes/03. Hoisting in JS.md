# Hoisting in JavaScript
## Introduction

Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their containing scope during the compilation phase, before the code is executed.

## Table of Contents

1. [What is Hoisting?](#what-is-hoisting)
2. [Variable Hoisting](#variable-hoisting)
3. [Function Hoisting](#function-hoisting)
4. [Hoisting Order](#hoisting-order)
5. [Call Stack Representation](#call-stack-representation)
6. [Best Practices](#best-practices)

## What is Hoisting?

Before executing code, JavaScript engine:
1. Creates a Global Execution Context
2. Goes through the code in two phases:
  - Memory Creation Phase (Hoisting happens here)
  - Code Execution Phase

Visual representation of the process:

```
┌─────────────────────────────────────┐
│   JavaScript Compilation Process    │
├─────────────────────────────────────┤
│                                     │
│  1. Memory Creation Phase           │
│     - Allocate memory for variables │
│     - Set variables to undefined    │
│     - Store function definitions    │
│                                     │
│  2. Code Execution Phase            │
│     - Execute code line by line     │
│     - Assign actual values          │
│                                     │
└─────────────────────────────────────┘
```

Call stack representation during execution:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After execution starts:
┌───────────────┐
│ Global Context│
└───────────────┘
```

## Variable Hoisting

### var Variables

Variables declared with `var` are hoisted and initialized with `undefined`.

```javascript
console.log(x); // undefined (not ReferenceError)
var x = 10;
console.log(x); // 10
```

Visual representation:

```
Memory Creation Phase:
┌──────────────┐
│ x: undefined │
└──────────────┘

Code Execution Phase:
Line 1: console.log(x) -> outputs undefined
Line 2: x = 10
Line 3: console.log(x) -> outputs 10
```

Call stack representation:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After first console.log(x):
┌───────────────┐
│ console.log() │
├───────────────┤
│ Global Context│
└───────────────┘

After second console.log(x):
┌───────────────┐
│ console.log() │
├───────────────┤
│ Global Context│
└───────────────┘

After execution finishes:
┌───────────────┐
│ Global Context│
└───────────────┘
```

### let and const Variables

Variables declared with `let` and `const` are hoisted but NOT initialized. Accessing them before declaration results in a `ReferenceError` (Temporal Dead Zone).

```javascript
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 20;
```

Visual representation:

```
Memory Creation Phase:
┌────────────────────────┐
│ y: <uninitialized>     │
│   (Temporal Dead Zone) │
└────────────────────────┘

Code Execution Phase:
Line 1: console.log(y) -> ReferenceError
Line 2: y = 20
```

Call stack representation:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After console.log(y):
┌───────────────┐
│ console.log() │
├───────────────┤
│ Global Context│
└───────────────┘

Error occurs:
┌───────────────────┐
│ ReferenceError    │
├───────────────────┤
│ console.log()     │
├───────────────────┤
│ Global Context    │
└───────────────────┘

After error handling:
┌───────────────┐
│ Global Context│
└───────────────┘
```

## Function Hoisting

### Function Declarations

Function declarations are completely hoisted with their implementation.

```javascript
sayHello(); // "Hello, World!" (works fine)

function sayHello() {
  console.log("Hello, World!");
}
```

Visual representation:

```
Memory Creation Phase:
┌───────────────────────────────────────────┐
│ sayHello: function() {                    │
│             console.log("Hello, World!"); │
│           }                               │
└───────────────────────────────────────────┘

Code Execution Phase:
Line 1: sayHello() -> outputs "Hello, World!"
Lines 3-5: Function definition (already processed)
```

Call stack representation:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After sayHello() is called:
┌───────────────┐
│ sayHello()    │
├───────────────┤
│ Global Context│
└───────────────┘

Within sayHello() during console.log:
┌───────────────┐
│ console.log() │
├───────────────┤
│ sayHello()    │
├───────────────┤
│ Global Context│
└───────────────┘

After sayHello() finishes:
┌───────────────┐
│ Global Context│
└───────────────┘
```

### Function Expressions

Function expressions using `var` follow variable hoisting rules:

```javascript
sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
  console.log("Hi there!");
};
```

Visual representation:

```
Memory Creation Phase:
┌─────────────────────┐
│ sayHi: undefined    │
└─────────────────────┘

Code Execution Phase:
Line 1: sayHi() -> TypeError (undefined is not a function)
Lines 3-5: sayHi = function...
```

Call stack representation:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After attempting sayHi():
┌───────────────┐
│ sayHi()       │
├───────────────┤
│ Global Context│
└───────────────┘

Error occurs:
┌───────────────────┐
│ TypeError         │
├───────────────────┤
│ sayHi()           │
├───────────────────┤
│ Global Context    │
└───────────────────┘

After error handling:
┌───────────────┐
│ Global Context│
└───────────────┘
```

## Call Stack Representation

The call stack is a mechanism for keeping track of function calls in JavaScript. When a function is invoked, it is added to the stack. Once the function execution is complete, it is removed from the stack.

Example:

```javascript
function first() {
  console.log("First function");
  second();
}

function second() {
  console.log("Second function");
  third();
}

function third() {
  console.log("Third function");
}

first();
```

Call stack representation:

```
Initial State:
┌───────────────┐
│ Global Context│
└───────────────┘

After first() is called:
┌───────────────┐
│ first()       │
├───────────────┤
│ Global Context│
└───────────────┘

After second() is called:
┌───────────────┐
│ second()      │
├───────────────┤
│ first()       │
├───────────────┤
│ Global Context│
└───────────────┘

After third() is called:
┌───────────────┐
│ third()       │
├───────────────┤
│ second()      │
├───────────────┤
│ first()       │
├───────────────┤
│ Global Context│
└───────────────┘

After third() finishes:
┌───────────────┐
│ second()      │
├───────────────┤
│ first()       │
├───────────────┤
│ Global Context│
└───────────────┘

After second() finishes:
┌───────────────┐
│ first()       │
├───────────────┤
│ Global Context│
└───────────────┘

After first() finishes:
┌───────────────┐
│ Global Context│
└───────────────┘
```

## Best Practices

1. Always declare variables at the top of their scope
2. Use `let` and `const` instead of `var`
3. Use function declarations when you need hoisting
4. Understand temporal dead zone

```javascript
// Good practice
function example() {
  let a, b, c;
  
  // Code that uses these variables
  a = 5;
  b = 10;
  c = a + b;
}
```

## Summary

| Feature | Hoisted? | Initial Value | Scope |
|---------|----------|--------------|-------|
| var | Yes | undefined | Function |
| let | Yes | <TDZ> | Block |
| const | Yes | <TDZ> | Block |
| function | Yes | Entire function | Function |
| function expression | Depends on declaration | undefined/TDZ | Depends |

This understanding helps anticipate JavaScript behavior and avoid common pitfalls related to variable and function availability.
