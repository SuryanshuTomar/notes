# Type Aliases in C++

## What are Aliases?
Type aliases are alternative names for existing types. They allow you to create more readable, maintainable code by giving descriptive names to complex types.

## Types of Aliases in C++

### 1. `typedef` (C-style)
```cpp
// Basic type alias
typedef unsigned long long ull;
typedef std::vector<int> IntVector;
typedef int (*FuncPtr)(int, int);

// Usage examples
ull largeNumber = 1000000ULL;
IntVector numbers = {1, 2, 3, 4, 5};
FuncPtr operation = [](int a, int b) { return a + b; };
int result = operation(5, 3); // result = 8
```

### 2. `using` (Modern C++11+)
```cpp
// Basic type aliases
using ull = unsigned long long;
using IntVector = std::vector<int>;
using FuncPtr = int(*)(int, int);

// Template aliases (only with 'using')
template<typename T>
using Vec = std::vector<T>;

template<typename K, typename V>
using Map = std::unordered_map<K, V>;

// Usage examples
ull largeNumber = 1000000ULL;
IntVector numbers = {1, 2, 3, 4, 5};
Vec<std::string> names = {"Alice", "Bob", "Charlie"};
Map<std::string, int> scores = {{"Alice", 95}, {"Bob", 87}};
```

### 3. `auto` (Type Deduction)
```cpp
// Basic type deduction
auto x = 42;        // int
auto y = 3.14;      // double
auto z = "hello";   // const char*

// Usage examples
auto numbers = std::vector<int>{1, 2, 3, 4, 5};
auto it = numbers.begin(); // std::vector<int>::iterator
auto lambda = [](int x) { return x * 2; }; // lambda type

for (auto& num : numbers) {
    num *= 2; // doubles each number
}
```

## Benefits of Type Aliases

### 1. **Improved Readability**
```cpp
// Before
std::map<std::string, std::vector<std::pair<int, double>>> data;

// After
using StudentGrades = std::map<std::string, std::vector<std::pair<int, double>>>;
StudentGrades data;

// Usage example
data["John"] = {{90, 3.5}, {85, 3.2}};
data["Jane"] = {{95, 3.8}, {92, 3.7}};
```

### 2. **Easier Maintenance**
```cpp
using UserID = uint64_t;  // Easy to change type later

void processUser(UserID id) { 
    std::cout << "Processing user: " << id << std::endl;
}

// Usage
UserID currentUser = 12345;
processUser(currentUser);
```

### 3. **Template Simplification**
```cpp
template<typename T>
using UniquePtr = std::unique_ptr<T>;

template<typename T>
using SharedPtr = std::shared_ptr<T>;

// Usage examples
UniquePtr<int> ptr = std::make_unique<int>(42);
SharedPtr<std::string> strPtr = std::make_shared<std::string>("Hello");
std::cout << *ptr << ", " << *strPtr << std::endl;
```

### 4. **Platform Independence**
```cpp
using size_type = std::size_t;
using byte = unsigned char;

// Usage examples
size_type arraySize = 100;
byte buffer[256];
byte value = 0xFF;
```

## Best Practices
- Prefer `using` over `typedef` for new code
- Use meaningful names that describe the purpose
- Keep aliases in appropriate scope (namespace, class, or local)
- Use template aliases for generic programming