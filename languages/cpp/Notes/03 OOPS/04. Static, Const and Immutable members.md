# Static and Const Members in C++

## Static Members

### What are Static Members?
Static members belong to the class itself rather than to any specific instance of the class. They are shared among all objects of the class.

### Static Data Members

#### Syntax:
```cpp
class ClassName {
    static type memberName;  // Declaration inside class
};

// Definition outside class (required)
type ClassName::memberName = initialValue;
```

- Declared with `static` keyword
- Only one copy exists for the entire class
- Initialized outside the class definition
- Accessed using class name or object reference

```cpp
class Counter {
private:
    static int count;  // Declaration
public:
    Counter() { count++; }
    static int getCount() { return count; }
};

int Counter::count = 0;  // Definition and initialization
```

#### Detailed Example: Database Connection Pool
```cpp
class DatabaseConnection {
private:
    static int maxConnections;
    static int activeConnections;
    static std::vector<DatabaseConnection*> pool;
    bool inUse;
    
public:
    DatabaseConnection() : inUse(false) {
        if (activeConnections < maxConnections) {
            activeConnections++;
            pool.push_back(this);
        }
    }
    
    static DatabaseConnection* getConnection() {
        for (auto conn : pool) {
            if (!conn->inUse) {
                conn->inUse = true;
                return conn;
            }
        }
        return nullptr; // No available connections
    }
    
    static int getActiveCount() { return activeConnections; }
    static void setMaxConnections(int max) { maxConnections = max; }
};

// Static member definitions
int DatabaseConnection::maxConnections = 10;
int DatabaseConnection::activeConnections = 0;
std::vector<DatabaseConnection*> DatabaseConnection::pool;
```

**When to use**: Resource management, shared counters, configuration data that applies to all instances.

### Static Member Functions

#### Syntax:
```cpp
class ClassName {
public:
    static returnType functionName(parameters);  // Declaration
};

// Usage
ClassName::functionName(arguments);  // Call without object
// OR
objectName.functionName(arguments);  // Call with object
```

- Can be called without creating an object
- Cannot access non-static members directly
- No `this` pointer available
- Accessed using scope resolution operator

```cpp
class MathUtils {
public:
    static int add(int a, int b) {
        return a + b;
    }
};

// Usage: MathUtils::add(5, 3)
```

#### Detailed Example: Factory Pattern
```cpp
class Logger {
public:
    enum LogLevel { DEBUG, INFO, WARNING, ERROR };
    
private:
    LogLevel level;
    std::string filename;
    
    Logger(LogLevel lvl, const std::string& file) : level(lvl), filename(file) {}
    
public:
    // Factory methods (static)
    static Logger* createFileLogger(const std::string& filename) {
        return new Logger(INFO, filename);
    }
    
    static Logger* createConsoleLogger() {
        return new Logger(DEBUG, "console");
    }
    
    static Logger* createErrorLogger() {
        return new Logger(ERROR, "error.log");
    }
    
    void log(const std::string& message) {
        // Implementation depends on logger type
        std::cout << "[" << filename << "] " << message << std::endl;
    }
};

// Usage
Logger* fileLogger = Logger::createFileLogger("app.log");
Logger* consoleLogger = Logger::createConsoleLogger();
```

**When to use**: Factory methods, utility functions, validation functions, mathematical operations.

#### Detailed Example: Singleton Pattern
```cpp
class ConfigManager {
private:
    static ConfigManager* instance;
    std::map<std::string, std::string> settings;
    
    ConfigManager() = default; // Private constructor
    
public:
    static ConfigManager* getInstance() {
        if (instance == nullptr) {
            instance = new ConfigManager();
        }
        return instance;
    }
    
    void setSetting(const std::string& key, const std::string& value) {
        settings[key] = value;
    }
    
    std::string getSetting(const std::string& key) const {
        auto it = settings.find(key);
        return (it != settings.end()) ? it->second : "";
    }
    
    static void cleanup() {
        delete instance;
        instance = nullptr;
    }
};

ConfigManager* ConfigManager::instance = nullptr;

// Usage
ConfigManager::getInstance()->setSetting("theme", "dark");
std::string theme = ConfigManager::getInstance()->getSetting("theme");
```

### Why Static Members are Needed
- **Shared data**: Count instances, maintain global state
- **Utility functions**: Math operations, helper functions
- **Memory efficiency**: One copy for all objects
- **Class-level operations**: Factory methods, singletons

## Const Members

### What are Const Members?
Const members ensure immutability and prevent modification of data or behavior.

### Const Data Members

#### Syntax:
```cpp
class ClassName {
private:
    const type memberName;           // Must be initialized in constructor
    const type memberName = value;   // C++11 in-class initialization
    
public:
    ClassName(type val) : memberName(val) {}  // Member initializer list (required)
};
```

- Must be initialized using member initializer list
- Cannot be modified after initialization
- Each object has its own copy

```cpp
class Circle {
private:
    const double PI = 3.14159;  // C++11 in-class initialization
    const int id;
public:
    Circle(int _id) : id(_id) {}  // Member initializer list
};
```

#### Detailed Example: Immutable Configuration Object
```cpp
class ServerConfig {
private:
    const std::string serverName;
    const int port;
    const std::string protocol;
    const bool sslEnabled;
    const std::chrono::seconds timeout;
    
public:
    ServerConfig(const std::string& name, int p, const std::string& proto, 
                bool ssl, int timeoutSecs)
        : serverName(name), port(p), protocol(proto), 
          sslEnabled(ssl), timeout(timeoutSecs) {}
    
    // Const getters
    const std::string& getServerName() const { return serverName; }
    int getPort() const { return port; }
    const std::string& getProtocol() const { return protocol; }
    bool isSSLEnabled() const { return sslEnabled; }
    std::chrono::seconds getTimeout() const { return timeout; }
    
    // Utility function
    std::string getConnectionString() const {
        return protocol + "://" + serverName + ":" + std::to_string(port);
    }
};

// Usage
ServerConfig webServer("localhost", 8080, "https", true, 30);
std::cout << webServer.getConnectionString(); // Cannot modify any member
```

**When to use**: Configuration objects, immutable data, object identifiers, mathematical constants.

### Const Member Functions

#### Syntax:
```cpp
class ClassName {
public:
    returnType functionName(parameters) const;  // Const member function declaration
    
    // Definition
    returnType functionName(parameters) const {
        // Cannot modify non-mutable members
        // Can only call other const member functions
        return someValue;
    }
};

// Usage with const objects
const ClassName obj;
obj.functionName(args);  // Only const functions can be called
```

- Cannot modify any non-mutable data members
- Can be called on const objects
- Provide read-only access to object state

```cpp
class Rectangle {
private:
    double width, height;
public:
    double getArea() const {  // const member function
        return width * height;
    }
    
    void setWidth(double w) {  // non-const function
        width = w;
    }
};
```

### Const Member Functions Returning References

#### Syntax:
```cpp
class ClassName {
private:
    type memberData;
    
public:
    // Return const reference - prevents modification of returned data
    const type& getMemberData() const {
        return memberData;
    }
    
    // Non-const version - allows modification
    type& getMemberData() {
        return memberData;
    }
    
    // Return by value - creates copy (safe but potentially expensive)
    type getMemberDataCopy() const {
        return memberData;
    }
};

// Usage
const ClassName obj;
const auto& data = obj.getMemberData();  // No copy, read-only access
// data = newValue;  // ERROR: Cannot modify const reference
```

- `const type&` returns read-only reference to internal data
- No copying overhead for large objects
- Caller cannot modify the returned data
- Ensures data integrity while providing efficient access

```cpp
class Person {
private:
    std::string name;
    std::vector<std::string> hobbies;
    
public:
    Person(const std::string& n) : name(n) {}
    
    // Return const reference - efficient and safe
    const std::string& getName() const {
        return name;  // No copy, read-only access
    }
    
    const std::vector<std::string>& getHobbies() const {
        return hobbies;  // No copy of entire vector
    }
    
    // Non-const version for modification
    std::vector<std::string>& getHobbies() {
        return hobbies;  // Allows modification
    }
};

// Usage
const Person person("Alice");
const std::string& personName = person.getName();  // Efficient, no copy
std::cout << personName << std::endl;  // Can read but not modify
// personName = "Bob";  // ERROR: Cannot modify const reference
```

#### Detailed Example: Thread-Safe Read Operations
```cpp
class BankAccount {
private:
    mutable std::mutex accountMutex;
    double balance;
    std::string accountNumber;
    std::vector<std::string> transactionHistory;
    
public:
    BankAccount(const std::string& accNum, double initialBalance)
        : accountNumber(accNum), balance(initialBalance) {}
    
    // Const member functions for read-only operations
    double getBalance() const {
        std::lock_guard<std::mutex> lock(accountMutex);
        return balance;
    }
    
    const std::string& getAccountNumber() const {
        return accountNumber; // No lock needed for const data
    }
    
    std::vector<std::string> getTransactionHistory() const {
        std::lock_guard<std::mutex> lock(accountMutex);
        return transactionHistory; // Returns copy
    }
    
    bool hasMinimumBalance(double minimum) const {
        std::lock_guard<std::mutex> lock(accountMutex);
        return balance >= minimum;
    }
    
    // Non-const member functions for modifications
    void deposit(double amount) {
        std::lock_guard<std::mutex> lock(accountMutex);
        balance += amount;
        transactionHistory.push_back("Deposit: $" + std::to_string(amount));
    }
    
    void withdraw(double amount) {
        std::lock_guard<std::mutex> lock(accountMutex);
        if (balance >= amount) {
            balance -= amount;
            transactionHistory.push_back("Withdrawal: $" + std::to_string(amount));
        }
    }
};

// Usage with const objects
void printAccountInfo(const BankAccount& account) {
    std::cout << "Account: " << account.getAccountNumber() << std::endl;
    std::cout << "Balance: $" << account.getBalance() << std::endl;
    // account.deposit(100); // ERROR: Cannot call non-const function
}
```

**When to use**: Getter functions, query operations, calculations that don't modify state, functions called on const objects.

### Why Const Members are Needed
- **Data integrity**: Prevent accidental modifications
- **Interface design**: Clear distinction between read/write operations
- **Compiler optimization**: Better code generation
- **Type safety**: Const-correctness in function parameters

## Mutable Members

### What is Mutable?
The `mutable` keyword allows specific data members to be modified even within const member functions. It breaks the const contract for implementation details while maintaining logical constness.

### Mutable Data Members

#### Syntax:
```cpp
class ClassName {
private:
    mutable type memberName;  // Can be modified in const functions
    
public:
    returnType function() const {
        memberName = newValue;  // Allowed due to mutable
        return someValue;
    }
};
```

- Can be modified in const member functions
- Used for caching, debugging, or temporary data
- Doesn't affect the logical state of the object
- Enables lazy evaluation and optimization

```cpp
class BasicCache {
private:
    mutable int accessCount = 0;  // Can be modified in const functions
    int value;
public:
    BasicCache(int v) : value(v) {}
    
    int getValue() const {
        accessCount++;  // Allowed due to mutable
        return value;
    }
    
    int getAccessCount() const {
        return accessCount;
    }
};
```

#### Detailed Example: Lazy Evaluation with Caching
```cpp
class ExpensiveCalculator {
private:
    std::vector<int> data;
    mutable bool sumCached;
    mutable int cachedSum;
    mutable bool avgCached;
    mutable double cachedAvg;
    mutable std::chrono::time_point<std::chrono::steady_clock> lastAccess;
    mutable std::mutex cacheMutex;  // Thread safety for cache
    
public:
    ExpensiveCalculator(std::vector<int> inputData) 
        : data(std::move(inputData)), sumCached(false), avgCached(false) {}
    
    int getSum() const {
        std::lock_guard<std::mutex> lock(cacheMutex);
        lastAccess = std::chrono::steady_clock::now();
        
        if (!sumCached) {
            cachedSum = 0;
            for (int value : data) {
                cachedSum += value;
                // Simulate expensive calculation
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
            }
            sumCached = true;
        }
        return cachedSum;
    }
    
    double getAverage() const {
        std::lock_guard<std::mutex> lock(cacheMutex);
        lastAccess = std::chrono::steady_clock::now();
        
        if (!avgCached) {
            if (!sumCached) {
                // Reuse sum calculation
                lock.~lock_guard();  // Unlock before recursive call
                getSum();  // This will set sumCached
                std::lock_guard<std::mutex> newLock(cacheMutex);
            }
            cachedAvg = data.empty() ? 0.0 : static_cast<double>(cachedSum) / data.size();
            avgCached = true;
        }
        return cachedAvg;
    }
    
    std::chrono::duration<double> getTimeSinceLastAccess() const {
        std::lock_guard<std::mutex> lock(cacheMutex);
        auto now = std::chrono::steady_clock::now();
        return now - lastAccess;
    }
    
    void addData(int value) {
        std::lock_guard<std::mutex> lock(cacheMutex);
        data.push_back(value);
        // Invalidate all caches
        sumCached = false;
        avgCached = false;
    }
    
    size_t size() const {
        return data.size();
    }
};

// Usage
const ExpensiveCalculator calc({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
std::cout << "Sum: " << calc.getSum() << std::endl;        // Expensive first time
std::cout << "Sum again: " << calc.getSum() << std::endl;  // Fast (cached)
std::cout << "Average: " << calc.getAverage() << std::endl; // Uses cached sum
```

#### Detailed Example: Debug and Logging Information
```cpp
class NetworkConnection {
private:
    std::string serverAddress;
    int port;
    bool connected;
    
    // Mutable members for debugging/logging
    mutable int connectionAttempts;
    mutable std::vector<std::string> debugLog;
    mutable std::chrono::time_point<std::chrono::steady_clock> lastActivity;
    
public:
    NetworkConnection(const std::string& addr, int p) 
        : serverAddress(addr), port(p), connected(false), connectionAttempts(0) {}
    
    bool isConnected() const {
        // Update debug info even in const function
        lastActivity = std::chrono::steady_clock::now();
        debugLog.push_back("Connection status checked at " + 
                          std::to_string(std::chrono::duration_cast<std::chrono::seconds>(
                              lastActivity.time_since_epoch()).count()));
        return connected;
    }
    
    std::string getConnectionInfo() const {
        lastActivity = std::chrono::steady_clock::now();
        return serverAddress + ":" + std::to_string(port) + 
               " (Attempts: " + std::to_string(connectionAttempts) + ")";
    }
    
    std::vector<std::string> getDebugLog() const {
        return debugLog;  // Return copy of debug information
    }
    
    void connect() {
        connectionAttempts++;  // This modifies mutable member indirectly
        lastActivity = std::chrono::steady_clock::now();
        debugLog.push_back("Connection attempt #" + std::to_string(connectionAttempts));
        
        // Simulate connection logic
        connected = true;
        debugLog.push_back("Connected successfully");
    }
    
    void disconnect() {
        connected = false;
        lastActivity = std::chrono::steady_clock::now();
        debugLog.push_back("Disconnected");
    }
};

// Usage
const NetworkConnection conn("192.168.1.1", 8080);
if (!conn.isConnected()) {
    std::cout << "Not connected to " << conn.getConnectionInfo() << std::endl;
}
// Debug info is still accessible from const object
auto logs = conn.getDebugLog();
for (const auto& log : logs) {
    std::cout << "Debug: " << log << std::endl;
}
```

#### Detailed Example: Reference Counting and Smart Pointers
```cpp
template<typename T>
class SharedResource {
private:
    T* resource;
    mutable int* refCount;  // Shared reference counter
    mutable std::mutex* refMutex;  // Thread safety for reference counting
    
    void cleanup() const {  // Can be called from const functions due to mutable
        if (refCount && --(*refCount) == 0) {
            delete resource;
            delete refCount;
            delete refMutex;
        }
    }
    
public:
    explicit SharedResource(T* res) 
        : resource(res), refCount(new int(1)), refMutex(new std::mutex()) {}
    
    // Copy constructor - modifies mutable members
    SharedResource(const SharedResource& other) 
        : resource(other.resource), refCount(other.refCount), refMutex(other.refMutex) {
        if (refCount) {
            std::lock_guard<std::mutex> lock(*refMutex);
            (*refCount)++;
        }
    }
    
    // Assignment operator
    SharedResource& operator=(const SharedResource& other) {
        if (this != &other) {
            cleanup();  // Clean up current resource
            
            resource = other.resource;
            refCount = other.refCount;
            refMutex = other.refMutex;
            
            if (refCount) {
                std::lock_guard<std::mutex> lock(*refMutex);
                (*refCount)++;
            }
        }
        return *this;
    }
    
    ~SharedResource() {
        cleanup();
    }
    
    // Const access to resource
    const T& get() const {
        return *resource;
    }
    
    T& get() {
        return *resource;
    }
    
    // Get reference count (const function, but accesses mutable data)
    int getRefCount() const {
        if (refCount) {
            std::lock_guard<std::mutex> lock(*refMutex);
            return *refCount;
        }
        return 0;
    }
    
    bool isUnique() const {
        return getRefCount() == 1;
    }
};

// Usage
SharedResource<std::string> res1(new std::string("Hello"));
const SharedResource<std::string> res2 = res1;  // Copy, increases ref count
std::cout << "Ref count: " << res1.getRefCount() << std::endl;  // 2
std::cout << "Resource: " << res2.get() << std::endl;  // "Hello"
```

**When to use**: Caching computed values, debug/logging information, reference counting, lazy initialization, performance monitoring.

### Why Mutable is Needed
- **Logical vs Physical Constness**: Separate what the object represents from implementation details
- **Performance Optimization**: Enable caching without breaking const interface
- **Debugging and Monitoring**: Track usage patterns without affecting object state
- **Thread Safety**: Modify synchronization primitives in const functions
- **Lazy Evaluation**: Defer expensive computations until needed

### Mutable Best Practices
- Use sparingly and only for implementation details
- Document why mutable is necessary
- Ensure thread safety when using mutable with const functions
- Don't use mutable to bypass legitimate const restrictions
- Consider if the design can be improved instead of using mutable

## Combining Static and Const

#### Syntax:
```cpp
class ClassName {
public:
    static const type memberName = value;    // Static const data member
    static const type memberName;            // Declaration (definition needed outside)
    
    static const returnType functionName() const;  // Static const function (rare)
    // Note: static const functions are uncommon; usually just static
};

// For non-integral types, definition outside class:
const type ClassName::memberName = value;
```

```cpp
class Config {
private:
    static const int MAX_SIZE = 100;  // Static const data member
public:
    static const char* getVersion() {  // Static const function
        return "1.0.0";
    }
};
```

#### Detailed Example: Application Constants and Utilities
```cpp
class GameConstants {
public:
    // Static const data members - shared across all instances
    static const int MAX_PLAYERS = 4;
    static const int BOARD_SIZE = 10;
    static const double GRAVITY = 9.81;
    static const std::string GAME_NAME;
    
    // Static const member functions
    static const std::string& getGameName() {
        return GAME_NAME;
    }
    
    static double calculateFallDistance(double time) {
        return 0.5 * GRAVITY * time * time;
    }
    
    static bool isValidPlayerCount(int count) {
        return count > 0 && count <= MAX_PLAYERS;
    }
    
    static std::vector<std::string> getDefaultPlayerNames() {
        static const std::vector<std::string> names = {
            "Player1", "Player2", "Player3", "Player4"
        };
        return names;
    }
};

// Static member definition
const std::string GameConstants::GAME_NAME = "Super Adventure Game";

// Usage
if (GameConstants::isValidPlayerCount(playerCount)) {
    std::cout << "Welcome to " << GameConstants::getGameName() << std::endl;
    double distance = GameConstants::calculateFallDistance(2.5);
}
```

## Best Practices

### When to Use Static Members
1. **Counters and Statistics**: Track number of instances, function calls
2. **Utility Functions**: Mathematical operations, string processing
3. **Factory Methods**: Creating objects with specific configurations
4. **Singletons**: Ensuring only one instance exists
5. **Constants**: Values shared across all instances

### When to Use Const Members
1. **Immutable Properties**: Object IDs, creation timestamps
2. **Configuration Data**: Settings that shouldn't change after initialization
3. **Read-Only Access**: Getter functions, query operations
4. **Thread Safety**: Functions that guarantee no state modification
5. **API Design**: Clear contracts about what functions can/cannot modify

### When to Use Mutable Members
1. **Caching Mechanisms**: Store computed results for performance
2. **Debug Information**: Logging, profiling, monitoring data
3. **Reference Counting**: Smart pointer implementations
4. **Lazy Initialization**: Defer expensive operations
5. **Thread Synchronization**: Mutexes and locks in const functions

### Combined Usage Guidelines
- Use `static const` for compile-time constants shared by all instances
- Prefer `constexpr` for compile-time computations when possible
- Use const-correctness throughout your API design
- Consider thread safety when using static members
- Initialize const members properly using initializer lists
- Use mutable sparingly and only for implementation details