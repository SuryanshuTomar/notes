# Execution Context in JavaScript

## Table of Contents
- [Introduction](#introduction)
- [Types of Execution Context](#types-of-execution-context)
- [Phases of Execution Context](#phases-of-execution-context)
- [Memory Allocation in Execution Context](#memory-allocation-in-execution-context)
- [Call Stack](#call-stack)
- [Visual Representation](#visual-representation)
- [Key Points to Remember](#key-points-to-remember)

## Introduction

1. Execution Context is a concept in JavaScript that defines the environment in which code is executed. It determines what variables, functions, and objects are accessible during the execution of code.
2. Javscript is a Synchronous, Single-Threaded Language. Which means javascript can only executes one command at a time.

Note : Everything in JavaScript happens inside an Execution Context.

For a detailed explanation, refer to this [video tutorial](https://www.youtube.com/watch?v=ZvbzSrg0afE&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=2).

---

## **Types of Execution Context**

1. **Global Execution Context (GEC)**  
    - Created when the JavaScript file starts execution.  
    - It is the default execution context.  
    - Contains global variables and functions.  
    - `this` refers to the global object (`window` in browsers, `global` in Node.js).

2. **Function Execution Context (FEC)**  
    - Created whenever a function is invoked.  
    - Each function call gets its own execution context.  
    - Contains:  
      - **Arguments Object**: Array-like object holding function arguments.  
      - **Local Variables**: Variables declared inside the function.  
      - **`this` Keyword**: Depends on how the function is called.

3. **Eval Execution Context**  
    - Created when `eval()` is used to execute code.  
    - Rarely used and not recommended.

---

## **Phases of Execution Context**

### 1. **Creation Phase**
    - Memory is allocated for variables and functions.  
    - Variables are set to `undefined`.  
    - Functions are stored in memory as-is.  
    - `this` is determined.

### 2. **Execution Phase**
    - Code is executed line by line.  
    - Variables are assigned values.  
    - Functions are invoked.

---

## **Memory Allocation in Execution Context**

Each execution context has two main components:

1. **Memory Component (Variable Environment)**
    - Stores variables and functions as key-value pairs
    - Also called the "Variable Environment"

2. **Code Component (Thread of Execution)**
    - Executes code line by line
    - Also called the "Thread of Execution"

### **Visual Representation of Memory Allocation**

```plaintext
+-----------------------------------------------+
|           EXECUTION CONTEXT                   |
|                                               |
|  +-------------------+  +------------------+  |
|  |  Memory Component |  |  Code Component  |  |
|  |  (Variable Env)   |  |  (Execution)     |  |
|  +-------------------+  +------------------+  |
|  |                   |  |                  |  |
|  |  x: undefined     |  |  Line by line    |  |
|  |  → later x: 10    |  |  code execution  |  |
|  |                   |  |                  |  |
|  |  func: {...}      |  |                  |  |
|  |                   |  |                  |  |
|  +-------------------+  +------------------+  |
|                                               |
+-----------------------------------------------+
```

### **Example with Memory Snapshots**

```javascript
let a = 5;
function calc() {
  let b = 10;
  return a + b;
}
let sum = calc();
```

**Memory Evolution:**

1. **Global EC Creation Phase:**
```plaintext
Memory:
a: undefined
calc: function {...}
sum: undefined
```

2. **Global EC Execution Phase (before calc call):**
```plaintext
Memory:
a: 5
calc: function {...}
sum: undefined
```

3. **calc EC Creation Phase:**
```plaintext
Memory (calc):
b: undefined
```

4. **calc EC Execution Phase:**
```plaintext
Memory (calc):
b: 10
```

5. **Global EC after calc returns:**
```plaintext
Memory:
a: 5
calc: function {...}
sum: 15
```

---

## **Call Stack**

The **Call Stack** is a data structure that manages execution contexts.  
- **Global Execution Context** is pushed first.  
- Each function call creates a new **Function Execution Context** and is pushed onto the stack.  
- When a function completes, its context is popped off the stack.

**Example:**
```javascript
function first() {
  second();
  console.log('First');
}

function second() {
  console.log('Second');
}

first();
```

**Call Stack Flow:**
1. `GEC` → `first()` → `second()`  
2. `second()` completes → `first()` completes → `GEC` completes.

---

## **Visual Representation**

```plaintext
Call Stack:
+-------------------+
| Global Context    | <-- Initial state
+-------------------+

+-------------------+
| first() Context   | <-- first() is called
+-------------------+
| Global Context    |
+-------------------+

+-------------------+
| second() Context  | <-- second() is called
+-------------------+
| first() Context   |
+-------------------+
| Global Context    |
+-------------------+

Execution completes:
+-------------------+
| Global Context    | <-- Back to global
+-------------------+
```

---

## **Key Points to Remember**
- Only one execution context is active at a time.  
- JavaScript is single-threaded, meaning it executes one task at a time.  
- The Call Stack ensures proper execution order.  
- Hoisting occurs during the creation phase.
- Understanding memory allocation helps explain concepts like hoisting, closures, and scope in JavaScript.