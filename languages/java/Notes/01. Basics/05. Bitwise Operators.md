# Bitwise Operators in Java

Bitwise operators work directly on the binary (bit-level) representation of numbers. They are useful for tasks like setting, clearing, or toggling specific bits.

## List of Bitwise Operators

| Operator | Name                | Description                                 |
|----------|---------------------|---------------------------------------------|
| `&`      | AND                 | Sets each bit to 1 if both bits are 1       |
| `|`      | OR                  | Sets each bit to 1 if one of two bits is 1  |
| `^`      | XOR (exclusive OR)  | Sets each bit to 1 if only one bit is 1     |
| `~`      | NOT (complement)    | Inverts all the bits                        |
| `<<`     | Left Shift          | Shifts bits to the left, fills with 0s      |
| `>>`     | Right Shift         | Shifts bits to the right, preserves sign    |
| `>>>`    | Unsigned Right Shift| Shifts bits to the right, fills with 0s     |

---

## Visual Representation (Step-by-Step)

### 1. AND (`&`)

**Rule:** Only 1 & 1 gives 1, otherwise 0.

| Bit 1 | Bit 2 | Result |
|-------|-------|--------|
|   0   |   0   |   0    |
|   0   |   1   |   0    |
|   1   |   0   |   0    |
|   1   |   1   |   1    |

**Example:**
```java
int a = 5;   // 0101
int b = 3;   // 0011
int c = a & b; // 0001 (1)
```
```
    0 1 0 1   (5)
&   0 0 1 1   (3)
-------------
    0 0 0 1   (1)
```

---

### 2. OR (`|`)

**Rule:** 1 if at least one bit is 1.

| Bit 1 | Bit 2 | Result |
|-------|-------|--------|
|   0   |   0   |   0    |
|   0   |   1   |   1    |
|   1   |   0   |   1    |
|   1   |   1   |   1    |

**Example:**
```java
int a = 5;   // 0101
int b = 3;   // 0011
int c = a | b; // 0111 (7)
```
```
    0 1 0 1   (5)
|   0 0 1 1   (3)
-------------
    0 1 1 1   (7)
```

---

### 3. XOR (`^`)

**Rule:** 1 if bits are different, 0 if same.

| Bit 1 | Bit 2 | Result |
|-------|-------|--------|
|   0   |   0   |   0    |
|   0   |   1   |   1    |
|   1   |   0   |   1    |
|   1   |   1   |   0    |

**Example:**
```java
int a = 5;   // 0101
int b = 3;   // 0011
int c = a ^ b; // 0110 (6)
```
```
    0 1 0 1   (5)
^   0 0 1 1   (3)
-------------
    0 1 1 0   (6)
```

---

### 4. NOT (`~`)

**Rule:** Flips every bit (0 becomes 1, 1 becomes 0).

**Example:**
```java
int a = 5;   // 0000 0101
int c = ~a;  // 1111 1010 (-6)
```
```
~ 0 0 0 0  0 1 0 1   (5)
----------------------
  1 1 1 1  1 0 1 0  (-6)
```
*Note: The result is negative due to two's complement representation.*

---

### 5. Left Shift (`<<`)

**Rule:** Shifts all bits to the left, adds 0s on the right.

**Example:**
```java
int a = 5;   // 0000 0101
int c = a << 1; // 0000 1010 (10)
```
```
Before: 0 0 0 0  0 1 0 1   (5)
Shift:  0 0 0 0  1 0 1 0   (10)
```
*Each bit moves one place to the left; rightmost bit becomes 0.*

---

### 6. Right Shift (`>>`)

**Rule:** Shifts all bits to the right, leftmost bit (sign bit) stays the same.

**Example:**
```java
int a = 5;   // 0000 0101
int c = a >> 1; // 0000 0010 (2)
```
```
Before: 0 0 0 0  0 1 0 1   (5)
Shift:  0 0 0 0  0 0 1 0   (2)
```
*Each bit moves one place to the right; leftmost bit is filled with the sign bit.*

---

### 7. Unsigned Right Shift (`>>>`)

**Rule:** Shifts all bits to the right, fills leftmost bits with 0 (ignores sign).

**Example:**
```java
int a = -5;  // 1111...1011
int c = a >>> 1; // 0111...1101
```
```
Before: 1 1 1 1 ... 1 0 1 1   (-5)
Shift:  0 1 1 1 ... 1 1 0 1   (large positive number)
```
*All bits move right, leftmost is always 0.*

---

## Summary Table

| Operator | Example | Result (Decimal) | Result (Binary) |
|----------|---------|------------------|-----------------|
| `&`      | 5 & 3   | 1                | 0001            |
| `|`      | 5 \| 3  | 7                | 0111            |
| `^`      | 5 ^ 3   | 6                | 0110            |
| `~`      | ~5      | -6               | 1111 1010       |
| `<<`     | 5 << 1  | 10               | 0000 1010       |
| `>>`     | 5 >> 1  | 2                | 0000 0010       |
| `>>>`    | -5 >>> 1| 2147483645       | 0111...1101     |

---

**Tip:** Bitwise operators are only applicable to integer types (`byte`, `short`, `int`, `long`, `char`).

---

## How to View the Binary Representation in Java

You can use Java's built-in methods to view the binary representation of numbers:

### For Integers (`int`, `long`)

Use `Integer.toBinaryString()` or `Long.toBinaryString()`:

```java
int num = 5;
System.out.println(Integer.toBinaryString(num)); // Output: 101

long lnum = 10L;
System.out.println(Long.toBinaryString(lnum)); // Output: 1010
```

### For Other Types

- **`byte` and `short`**: Cast to `int` before using `Integer.toBinaryString()`.
- **`char`**: Cast to `int` and use `Integer.toBinaryString()`.

```java
byte b = 7;
System.out.println(Integer.toBinaryString(b & 0xFF)); // Output: 111

char c = 'A';
System.out.println(Integer.toBinaryString(c)); // Output: 1000001
```

*Note: For negative numbers, the output shows the two's complement binary form.*
*Note: Bitwise operators are faster than the Arithemetic operators.*

---