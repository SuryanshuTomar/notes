# Structures in C++

## What are Structures?

A **structure** in C++ is a user-defined data type that allows you to group related data items of different types under a single name. Structures are similar to classes but have some key differences in their default behavior.

### Basic Syntax

```cpp
struct StructureName {
    // Data members
    data_type member1;
    data_type member2;
    
    // Member functions (optional)
    return_type function_name();
} name_of_structure; // Declaration of structure variable
```
- Here, there are 2 parts: the definition of the structure and the declaration of a variable of that structure type.
- There are also 2 ways to define a structure: with and without a variable declaration.
- The first part defines the structure, and the second part declares a variable of that structure type.

### Example: Basic Structure

```cpp
struct Student {
    int id;
    string name;
    float gpa;
    
    // Member function
    void display() {
        cout << "ID: " << id << ", Name: " << name << ", GPA: " << gpa << endl;
    }
};
```

### Example: Using the Structure
```cpp
struct Point {
    int x;
    int y;
} p1; // Here, 'p1' is a variable of type 'Point'.

p1.x = 10; // Accessing members of the structure
p1.y = 20; // Setting values for members
```

## Key Features of Structures

### 1. **Default Access Level**
- All members in a structure are **public by default**
- No need to explicitly specify `public:` for basic access

```cpp
struct Point {
    int x, y;  // These are public by default
};

int main() {
    Point p;
    p.x = 10;  // Direct access allowed
    p.y = 20;
    return 0;
}
```

### 2. **Constructors and Destructors**
- Structures can have constructors and destructors
- Support both default and parameterized constructors

```cpp
struct Rectangle {
    int width, height;
    
    // Default constructor
    Rectangle() {
        width = height = 0;
    }
    
    // Parameterized constructor
    Rectangle(int w, int h) : width(w), height(h) {}
    
    // Destructor
    ~Rectangle() {
        cout << "Rectangle destroyed" << endl;
    }
    
    int area() {
        return width * height;
    }
};
```

### 3. **Member Functions**
- Structures can contain member functions
- Support function overloading and operator overloading

```cpp
struct Complex {
    double real, imag;
    
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // Operator overloading
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }
    
    void display() {
        cout << real << " + " << imag << "i" << endl;
    }
};
```

## Structures vs Classes

| Aspect | Structure | Class |
|--------|-----------|-------|
| **Default Access** | Public | Private |
| **Purpose** | Data grouping, simple objects | Complex objects with encapsulation |
| **Inheritance** | Supported (public by default) | Supported (private by default) |
| **Constructors/Destructors** | Supported | Supported |
| **Member Functions** | Supported | Supported |
| **Access Modifiers** | public, private, protected | public, private, protected |

### Key Differences Explained

#### 1. **Default Access Level**

```cpp
struct MyStruct {
    int data;  // Public by default
};

class MyClass {
    int data;  // Private by default
};

int main() {
    MyStruct s;
    s.data = 10;  // ✅ Works - public access
    
    MyClass c;
    // c.data = 10;  // ❌ Error - private access
    
    return 0;
}
```

#### 2. **Inheritance Default Access**

```cpp
struct Base {
    int value;
};

struct DerivedStruct : Base {  // Public inheritance by default
    void setValue(int v) { value = v; }  // Can access inherited member
};

class DerivedClass : Base {  // Private inheritance by default
    void setValue(int v) { 
        // value = v;  // ❌ Error - private inheritance
    }
};
```

## When to Use Structures vs Classes

### Use **Structures** When:

1. **Simple Data Containers**
   ```cpp
   struct Point2D {
       double x, y;
   };
   
   struct Color {
       int red, green, blue, alpha;
   };
   ```

2. **Plain Old Data (POD) Types**
   ```cpp
   struct Vector3 {
       float x, y, z;
       
       Vector3(float x = 0, float y = 0, float z = 0) : x(x), y(y), z(z) {}
   };
   ```

3. **Mathematical Objects**
   ```cpp
   struct Matrix2x2 {
       double data[2][2];
       
       Matrix2x2 operator*(const Matrix2x2& other);
       void print();
   };
   ```

4. **Configuration or Settings**
   ```cpp
   struct DatabaseConfig {
       string host;
       int port;
       string username;
       string database;
   };
   ```

### Use **Classes** When:

1. **Complex Objects with Encapsulation**
   ```cpp
   class BankAccount {
   private:
       double balance;
       string accountNumber;
       
   public:
       void deposit(double amount);
       bool withdraw(double amount);
       double getBalance() const;
   };
   ```

2. **Objects with Complex Behavior**
   ```cpp
   class FileManager {
   private:
       string fileName;
       bool isOpen;
       
   public:
       bool openFile(const string& name);
       void closeFile();
       bool writeData(const string& data);
   };
   ```

3. **When Data Should Be Hidden**
   ```cpp
   class PasswordManager {
   private:
       string encryptedPassword;
       
   public:
       bool setPassword(const string& password);
       bool verifyPassword(const string& input);
   };
   ```

## Advanced Structure Features

### 1. **Nested Structures**

Nested structures allow you to create hierarchical data organization within a single structure definition. This is particularly useful for grouping related sub-data.

#### Basic Nested Structures

```cpp
struct Employee {
    int id;
    string name;
    string department;
    
    // Nested structure for address
    struct Address {
        string street;
        string city;
        string state;
        int zipCode;
        string country;
        
        // Constructor for nested structure
        Address(const string& st = "", const string& c = "", 
                const string& state = "", int zip = 0, const string& country = "")
            : street(st), city(c), state(state), zipCode(zip), country(country) {}
        
        // Member function in nested structure
        string getFullAddress() const {
            return street + ", " + city + ", " + state + " " + to_string(zipCode) + ", " + country;
        }
    } address;
    
    // Another nested structure for contact info
    struct Contact {
        string email;
        string phone;
        string emergencyContact;
        string emergencyPhone;
        
        Contact(const string& e = "", const string& p = "", 
                const string& ec = "", const string& ep = "")
            : email(e), phone(p), emergencyContact(ec), emergencyPhone(ep) {}
        
        bool isValid() const {
            return !email.empty() && !phone.empty();
        }
    } contact;
    
    // Constructor for main structure
    Employee(int empId, const string& empName, const string& dept)
        : id(empId), name(empName), department(dept) {}
    
    // Method to display complete employee information
    void displayInfo() const {
        cout << "Employee ID: " << id << endl;
        cout << "Name: " << name << endl;
        cout << "Department: " << department << endl;
        cout << "Address: " << address.getFullAddress() << endl;
        cout << "Email: " << contact.email << endl;
        cout << "Phone: " << contact.phone << endl;
    }
};
```

#### Complex Nested Structure Example

```cpp
struct University {
    string name;
    string location;
    
    struct Department {
        string name;
        string head;
        int facultyCount;
        
        struct Course {
            string courseCode;
            string courseName;
            int credits;
            string instructor;
            
            struct Schedule {
                string day;
                string startTime;
                string endTime;
                string room;
                
                Schedule(const string& d, const string& start, 
                        const string& end, const string& r)
                    : day(d), startTime(start), endTime(end), room(r) {}
            };
            
            vector<Schedule> schedules;
            
            void addSchedule(const string& day, const string& start, 
                           const string& end, const string& room) {
                schedules.emplace_back(day, start, end, room);
            }
        };
        
        vector<Course> courses;
        
        void addCourse(const string& code, const string& name, 
                      int credits, const string& instructor) {
            Course newCourse;
            newCourse.courseCode = code;
            newCourse.courseName = name;
            newCourse.credits = credits;
            newCourse.instructor = instructor;
            courses.push_back(newCourse);
        }
    };
    
    vector<Department> departments;
};
```

#### Usage of Nested Structures

```cpp
int main() {
    // Creating and using nested structures
    Employee emp(101, "John Doe", "Software Engineering");
    
    // Setting address information
    emp.address = Employee::Address("123 Main St", "New York", "NY", 10001, "USA");
    
    // Setting contact information
    emp.contact = Employee::Contact("john.doe@company.com", "+1-555-0123", 
                                   "Jane Doe", "+1-555-0124");
    
    // Display complete information
    emp.displayInfo();
    
    // Accessing nested structure members
    cout << "ZIP Code: " << emp.address.zipCode << endl;
    cout << "Valid Contact: " << (emp.contact.isValid() ? "Yes" : "No") << endl;
    
    return 0;
}
```

### 2. **Template Structures**

Templates make structures generic and reusable with different data types.

#### Basic Template Structure

```cpp
template<typename T>
struct Pair {
    T first, second;
    
    // Default constructor
    Pair() : first(T{}), second(T{}) {}
    
    // Parameterized constructor
    Pair(const T& f, const T& s) : first(f), second(s) {}
    
    // Copy constructor
    Pair(const Pair<T>& other) : first(other.first), second(other.second) {}
    
    // Assignment operator
    Pair<T>& operator=(const Pair<T>& other) {
        if (this != &other) {
            first = other.first;
            second = other.second;
        }
        return *this;
    }
    
    // Comparison operators
    bool operator==(const Pair<T>& other) const {
        return first == other.first && second == other.second;
    }
    
    bool operator!=(const Pair<T>& other) const {
        return !(*this == other);
    }
    
    // Utility functions
    bool isEqual() const {
        return first == second;
    }
    
    void swap() {
        T temp = first;
        first = second;
        second = temp;
    }
    
    T getMax() const {
        return (first > second) ? first : second;
    }
    
    T getMin() const {
        return (first < second) ? first : second;
    }
};
```

#### Multi-Template Parameter Structure

```cpp
template<typename T, typename U>
struct KeyValuePair {
    T key;
    U value;
    
    KeyValuePair(const T& k, const U& v) : key(k), value(v) {}
    
    // Template member function
    template<typename V>
    void setValue(const V& newValue) {
        value = static_cast<U>(newValue);
    }
    
    void display() const {
        cout << "Key: " << key << ", Value: " << value << endl;
    }
};

// Specialized template for string keys
template<typename U>
struct KeyValuePair<string, U> {
    string key;
    U value;
    
    KeyValuePair(const string& k, const U& v) : key(k), value(v) {}
    
    // Special behavior for string keys
    void displayFormatted() const {
        cout << "\"" << key << "\" => " << value << endl;
    }
};
```

#### Template Structure with Multiple Types

```cpp
template<typename T, int Size>
struct StaticArray {
    T data[Size];
    int currentSize;
    
    StaticArray() : currentSize(0) {}
    
    bool add(const T& element) {
        if (currentSize < Size) {
            data[currentSize++] = element;
            return true;
        }
        return false;
    }
    
    T& operator[](int index) {
        if (index >= 0 && index < currentSize) {
            return data[index];
        }
        throw out_of_range("Index out of bounds");
    }
    
    const T& operator[](int index) const {
        if (index >= 0 && index < currentSize) {
            return data[index];
        }
        throw out_of_range("Index out of bounds");
    }
    
    int size() const { return currentSize; }
    int capacity() const { return Size; }
    bool isEmpty() const { return currentSize == 0; }
    bool isFull() const { return currentSize == Size; }
    
    void clear() { currentSize = 0; }
};
```

#### Usage Examples

```cpp
int main() {
    // Basic template usage
    Pair<int> intPair(10, 20);
    Pair<string> stringPair("Hello", "World");
    Pair<double> doublePair(3.14, 2.71);
    
    cout << "Int pair max: " << intPair.getMax() << endl;
    cout << "String pair equal: " << stringPair.isEqual() << endl;
    
    // Multi-template usage
    KeyValuePair<string, int> kvp("age", 25);
    kvp.display();
    
    KeyValuePair<int, string> reverseKvp(42, "answer");
    reverseKvp.display();
    
    // Static array usage
    StaticArray<int, 5> intArray;
    intArray.add(1);
    intArray.add(2);
    intArray.add(3);
    
    for (int i = 0; i < intArray.size(); i++) {
        cout << intArray[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 3. **Advanced Structure Initialization**

Modern C++ provides various ways to initialize structures efficiently and clearly.

#### Aggregate Initialization

```cpp
struct Product {
    int id;
    string name;
    double price;
    bool inStock;
    vector<string> categories;
};

struct ComplexProduct {
    int id;
    string name;
    double price;
    
    struct Supplier {
        string name;
        string contact;
        double rating;
    } supplier;
    
    vector<string> features;
};
```

#### Different Initialization Methods

```cpp
int main() {
    // 1. C++11 Uniform Initialization (Brace Initialization)
    Product p1{1, "Laptop", 999.99, true, {"Electronics", "Computers"}};
    
    // 2. Traditional Member-wise Assignment
    Product p2;
    p2.id = 2;
    p2.name = "Mouse";
    p2.price = 29.99;
    p2.inStock = true;
    p2.categories = {"Electronics", "Accessories"};
    
    // 3. C++20 Designated Initializers
    Product p3{
        .id = 3,
        .name = "Keyboard",
        .price = 79.99,
        .inStock = false,
        .categories = {"Electronics", "Input Devices"}
    };
    
    // 4. Complex structure initialization
    ComplexProduct cp{
        .id = 100,
        .name = "Gaming Monitor",
        .price = 299.99,
        .supplier = {"TechCorp", "tech@corp.com", 4.5},
        .features = {"4K", "144Hz", "HDR", "FreeSync"}
    };
    
    // 5. Copy initialization
    Product p4 = p1;
    
    // 6. Move initialization (C++11)
    Product p5 = std::move(p2);
    
    return 0;
}
```

#### Factory Functions for Complex Initialization

```cpp
struct DatabaseConnection {
    string host;
    int port;
    string username;
    string database;
    bool useSSL;
    int timeoutSeconds;
    
    // Factory functions for common configurations
    static DatabaseConnection createLocal(const string& db) {
        return DatabaseConnection{
            .host = "localhost",
            .port = 5432,
            .username = "user",
            .database = db,
            .useSSL = false,
            .timeoutSeconds = 30
        };
    }
    
    static DatabaseConnection createProduction(const string& host, 
                                              const string& db,
                                              const string& user) {
        return DatabaseConnection{
            .host = host,
            .port = 5432,
            .username = user,
            .database = db,
            .useSSL = true,
            .timeoutSeconds = 60
        };
    }
    
    static DatabaseConnection createCustom(const string& host, int port,
                                          const string& user, const string& db,
                                          bool ssl = true, int timeout = 30) {
        return DatabaseConnection{host, port, user, db, ssl, timeout};
    }
};
```

#### Initialization with Validation

```cpp
struct ValidatedProduct {
    int id;
    string name;
    double price;
    
    // Constructor with validation
    ValidatedProduct(int productId, const string& productName, double productPrice) {
        if (productId <= 0) throw invalid_argument("ID must be positive");
        if (productName.empty()) throw invalid_argument("Name cannot be empty");
        if (productPrice < 0) throw invalid_argument("Price cannot be negative");
        
        id = productId;
        name = productName;
        price = productPrice;
    }
    
    // Factory method with validation
    static ValidatedProduct create(int id, const string& name, double price) {
        return ValidatedProduct(id, name, price);
    }
};
```

#### Array of Structures Initialization

```cpp
int main() {
    // Array initialization
    Product products[] = {
        {1, "Item1", 10.99, true, {"Category1"}},
        {2, "Item2", 20.99, false, {"Category2"}},
        {3, "Item3", 30.99, true, {"Category1", "Category2"}}
    };
    
    // Vector initialization
    vector<Product> productVector = {
        {10, "VectorItem1", 15.99, true, {"Electronics"}},
        {11, "VectorItem2", 25.99, false, {"Books"}},
        {12, "VectorItem3", 35.99, true, {"Clothing"}}
    };
    
    // Using factory functions
    auto localDb = DatabaseConnection::createLocal("myapp_db");
    auto prodDb = DatabaseConnection::createProduction("prod.server.com", 
                                                      "production_db", 
                                                      "admin");
    
    return 0;
}
```

### 4. **Structure Inheritance and Polymorphism**

While less common than with classes, structures support inheritance and can exhibit polymorphic behavior.

#### Basic Structure Inheritance

```cpp
struct Shape {
    double x, y;  // Position
    
    Shape(double posX = 0, double posY = 0) : x(posX), y(posY) {}
    
    virtual double area() const = 0;  // Pure virtual function
    virtual double perimeter() const = 0;
    
    virtual void display() const {
        cout << "Position: (" << x << ", " << y << ")" << endl;
    }
    
    virtual ~Shape() = default;  // Virtual destructor
};

struct Rectangle : public Shape {
    double width, height;
    
    Rectangle(double w, double h, double x = 0, double y = 0)
        : Shape(x, y), width(w), height(h) {}
    
    double area() const override {
        return width * height;
    }
    
    double perimeter() const override {
        return 2 * (width + height);
    }
    
    void display() const override {
        Shape::display();
        cout << "Rectangle: " << width << " x " << height << endl;
        cout << "Area: " << area() << ", Perimeter: " << perimeter() << endl;
    }
};

struct Circle : public Shape {
    double radius;
    
    Circle(double r, double x = 0, double y = 0)
        : Shape(x, y), radius(r) {}
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    double perimeter() const override {
        return 2 * 3.14159 * radius;
    }
    
    void display() const override {
        Shape::display();
        cout << "Circle: radius = " << radius << endl;
        cout << "Area: " << area() << ", Perimeter: " << perimeter() << endl;
    }
};
```

#### Polymorphic Usage

```cpp
int main() {
    // Polymorphic array of shapes
    vector<unique_ptr<Shape>> shapes;
    
    shapes.push_back(make_unique<Rectangle>(5, 3, 10, 20));
    shapes.push_back(make_unique<Circle>(4, 15, 25));
    shapes.push_back(make_unique<Rectangle>(2, 8, 5, 10));
    
    // Polymorphic behavior
    for (const auto& shape : shapes) {
        shape->display();
        cout << "---" << endl;
    }
    
    return 0;
}
```

## Best Practices

### 1. **Use Appropriate Access Modifiers**
```cpp
struct Person {
private:
    string ssn;  // Sensitive data should be private
    
public:
    string name;
    int age;
    
    void setSSN(const string& social) {
        // Add validation logic
        ssn = social;
    }
};
```

### 2. **Const Correctness**
```cpp
struct Circle {
    double radius;
    
    double area() const {  // const member function
        return 3.14159 * radius * radius;
    }
    
    void setRadius(double r) {
        if (r > 0) radius = r;
    }
};
```

### 3. **Initialize Members**
```cpp
struct Timer {
    int hours, minutes, seconds;
    
    // Use member initializer list
    Timer(int h = 0, int m = 0, int s = 0) : hours(h), minutes(m), seconds(s) {}
};
```

## Memory Layout

```cpp
struct MemoryExample {
    char c;      // 1 byte
    int i;       // 4 bytes
    double d;    // 8 bytes
};

// Due to alignment, actual size might be larger than 13 bytes
cout << "Size: " << sizeof(MemoryExample) << " bytes" << endl;
```

## Common Pitfalls

1. **Forgetting to Initialize Members**
   ```cpp
   struct Point {
       int x, y;
       // Always initialize in constructor
       Point() : x(0), y(0) {}
   };
   ```

2. **Mixing Styles**
   ```cpp
   // Don't mix C-style and C++-style
   struct BadExample {
       int data;
   };
   
   // Bad: C-style declaration
   struct BadExample obj;
   
   // Good: C++-style declaration
   BadExample obj;
   ```

## Data Encapsulation: Classes vs Structures

### Understanding Encapsulation

**Encapsulation** is the principle of bundling data (attributes) and methods (functions) that operate on that data within a single unit, while restricting direct access to some of the object's components. This is a fundamental concept in object-oriented programming.

### How Classes Achieve Encapsulation

Classes are designed with encapsulation as a primary goal. By default, all members are private, which means:

```cpp
class BankAccount {
    // Private by default - ENCAPSULATED
    double balance;
    string accountNumber;
    vector<string> transactionHistory;
    
    // Private helper methods
    bool validateTransaction(double amount) {
        return amount > 0 && amount <= balance;
    }
    
    void logTransaction(const string& type, double amount) {
        transactionHistory.push_back(type + ": $" + to_string(amount));
    }

public:
    // Controlled access through public interface
    BankAccount(const string& accNum, double initialBalance) 
        : accountNumber(accNum), balance(initialBalance) {}
    
    // Controlled way to modify balance
    bool deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            logTransaction("Deposit", amount);
            return true;
        }
        return false;
    }
    
    bool withdraw(double amount) {
        if (validateTransaction(amount)) {
            balance -= amount;
            logTransaction("Withdrawal", amount);
            return true;
        }
        return false;
    }
    
    // Read-only access to balance
    double getBalance() const {
        return balance;
    }
    
    // No direct setter for balance - must use deposit/withdraw
    // This prevents invalid states like negative balance
};
```

**Benefits of Class Encapsulation:**
- **Data Protection**: Internal data cannot be directly modified
- **Validation**: All changes go through controlled methods
- **Consistency**: Object maintains valid state
- **Flexibility**: Internal implementation can change without affecting client code

### How Structures Handle Encapsulation

Structures, by default, expose all members publicly, which reduces encapsulation:

```cpp
struct StudentRecord {
    // All public by default - LIMITED ENCAPSULATION
    int studentId;
    string name;
    vector<double> grades;
    double gpa;
    
    // Constructor
    StudentRecord(int id, const string& studentName) 
        : studentId(id), name(studentName), gpa(0.0) {}
    
    // Helper function
    void calculateGPA() {
        if (!grades.empty()) {
            double sum = 0;
            for (double grade : grades) {
                sum += grade;
            }
            gpa = sum / grades.size();
        }
    }
};

int main() {
    StudentRecord student(123, "John Doe");
    
    // Direct access to all members - NO ENCAPSULATION
    student.grades.push_back(85.5);
    student.grades.push_back(92.0);
    
    // Problem: User can directly modify GPA without recalculating
    student.gpa = 100.0;  // This breaks data integrity!
    
    // Correct way would be:
    student.calculateGPA();
    
    return 0;
}
```

### Proper Encapsulation in Structures

You can achieve encapsulation in structures by explicitly using access modifiers:

```cpp
struct ImprovedStudentRecord {
private:
    // ENCAPSULATED data
    int studentId;
    string name;
    vector<double> grades;
    double gpa;
    
    // Private helper method
    void recalculateGPA() {
        if (!grades.empty()) {
            double sum = 0;
            for (double grade : grades) {
                sum += grade;
            }
            gpa = sum / grades.size();
        } else {
            gpa = 0.0;
        }
    }

public:
    // Constructor
    ImprovedStudentRecord(int id, const string& studentName) 
        : studentId(id), name(studentName), gpa(0.0) {}
    
    // Controlled access methods
    void addGrade(double grade) {
        if (grade >= 0 && grade <= 100) {
            grades.push_back(grade);
            recalculateGPA();  // Maintain consistency
        }
    }
    
    // Read-only access
    double getGPA() const { return gpa; }
    string getName() const { return name; }
    int getId() const { return studentId; }
    
    // No direct access to grades vector
    int getGradeCount() const { return grades.size(); }
};
```

### Real-World Comparison Examples

#### Example 1: Date Handling

**Class Approach (Strong Encapsulation):**
```cpp
class Date {
private:
    int day, month, year;
    
    bool isValidDate(int d, int m, int y) {
        if (m < 1 || m > 12) return false;
        if (d < 1 || d > daysInMonth(m, y)) return false;
        return y > 0;
    }
    
    int daysInMonth(int month, int year) {
        int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        if (month == 2 && isLeapYear(year)) return 29;
        return days[month - 1];
    }
    
    bool isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }

public:
    Date(int d, int m, int y) {
        if (isValidDate(d, m, y)) {
            day = d; month = m; year = y;
        } else {
            throw invalid_argument("Invalid date");
        }
    }
    
    // Controlled modification
    void setDate(int d, int m, int y) {
        if (isValidDate(d, m, y)) {
            day = d; month = m; year = y;
        } else {
            throw invalid_argument("Invalid date");
        }
    }
    
    // Read-only access
    int getDay() const { return day; }
    int getMonth() const { return month; }
    int getYear() const { return year; }
};
```

**Structure Approach (Minimal Encapsulation):**
```cpp
struct SimpleDate {
    int day, month, year;
    
    SimpleDate(int d, int m, int y) : day(d), month(m), year(y) {}
};

int main() {
    SimpleDate date(15, 6, 2025);
    
    // Problem: No validation - can create invalid dates
    date.day = 50;    // Invalid day
    date.month = 15;  // Invalid month
    date.year = -100; // Invalid year
    
    // The object is now in an invalid state!
    return 0;
}
```

#### Example 2: Temperature Sensor

**Class with Full Encapsulation:**
```cpp
class TemperatureSensor {
private:
    double currentTemp;
    double minTemp, maxTemp;
    bool isCalibrated;
    vector<double> readings;
    
    void validateTemperature(double temp) {
        if (temp < -273.15) {  // Below absolute zero
            throw invalid_argument("Temperature below absolute zero");
        }
    }

public:
    TemperatureSensor() : currentTemp(0), minTemp(0), maxTemp(0), isCalibrated(false) {}
    
    void calibrate(double min, double max) {
        if (min >= max) throw invalid_argument("Invalid calibration range");
        minTemp = min;
        maxTemp = max;
        isCalibrated = true;
    }
    
    void setTemperature(double temp) {
        if (!isCalibrated) throw runtime_error("Sensor not calibrated");
        validateTemperature(temp);
        
        currentTemp = temp;
        readings.push_back(temp);
    }
    
    double getTemperature() const {
        if (!isCalibrated) throw runtime_error("Sensor not calibrated");
        return currentTemp;
    }
    
    double getAverageReading() const {
        if (readings.empty()) return 0;
        double sum = 0;
        for (double reading : readings) sum += reading;
        return sum / readings.size();
    }
    
    bool isWithinRange() const {
        return currentTemp >= minTemp && currentTemp <= maxTemp;
    }
};
```

**Structure with Public Access:**
```cpp
struct BasicTemperatureSensor {
    double currentTemp;
    double minTemp, maxTemp;
    bool isCalibrated;
    vector<double> readings;
    
    BasicTemperatureSensor() : currentTemp(0), minTemp(0), maxTemp(0), isCalibrated(false) {}
};

int main() {
    BasicTemperatureSensor sensor;
    
    // Problems with direct access:
    sensor.currentTemp = -500;  // Below absolute zero - invalid!
    sensor.isCalibrated = true; // Lying about calibration
    sensor.minTemp = 100;
    sensor.maxTemp = 50;        // Max less than min - invalid range!
    
    // Object is in inconsistent state
    return 0;
}
```

### When Encapsulation Matters Most

**High Encapsulation Needed (Use Classes):**
1. **Financial Systems**: Bank accounts, transactions
2. **Security Systems**: Password managers, authentication
3. **System Resources**: File handles, network connections
4. **Complex State**: Game objects, UI components
5. **Data Integrity Critical**: Database records, scientific calculations

**Low Encapsulation Acceptable (Structures OK):**
1. **Simple Data Containers**: Points, colors, coordinates
2. **Configuration Objects**: Settings, parameters
3. **Mathematical Objects**: Vectors, matrices
4. **Temporary Data**: Function parameters, return values
5. **Performance-Critical Code**: Where direct access is needed

### Summary: Encapsulation Differences

| Aspect | Class Encapsulation | Structure Encapsulation |
|--------|-------------------|------------------------|
| **Default Access** | Private (hidden) | Public (exposed) |
| **Data Protection** | Strong by default | Weak by default |
| **Validation** | Built-in through methods | Manual implementation needed |
| **Consistency** | Maintained automatically | User responsibility |
| **Interface Control** | Clear public/private separation | All members accessible |
| **Flexibility** | Can change internals safely | Changes may break client code |

**Key Takeaway**: Classes provide **automatic encapsulation** while structures require **explicit effort** to achieve the same level of data protection.

## Summary

- **Structures** are ideal for simple data containers and mathematical objects
- **Classes** are better for complex objects requiring encapsulation
- The main difference is default access level (public vs private)
- Both support inheritance, constructors, destructors, and member functions
- Choose based on the complexity and data hiding requirements of your design

Remember: In modern C++, the choice between `struct` and `class` is often a matter of **intent and convention** rather than technical limitations.