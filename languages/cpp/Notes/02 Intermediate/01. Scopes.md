# Scopes in C++

## What is Scope?
Scope defines the region of a program where a particular variable, function, or object can be accessed. It determines the visibility and lifetime of identifiers.

## Types of Scopes in C++

### 1. Global Scope
Variables declared outside all functions and classes have global scope.

```cpp
#include <iostream>
int globalVar = 100; // Global scope

void function() {
    std::cout << globalVar << std::endl; // Accessible here
}

int main() {
    std::cout << globalVar << std::endl; // Accessible here
    return 0;
}
```

### 2. Local Scope (Function Scope)
Variables declared inside a function are local to that function.

```cpp
#include <iostream>

void function() {
    int localVar = 50; // Local scope
    std::cout << localVar << std::endl;
} // localVar destroyed here

int main() {
    function();
    // std::cout << localVar; // ERROR: localVar not accessible
    return 0;
}
```

### 3. Block Scope
Variables declared within braces `{}` have block scope.

```cpp
#include <iostream>

int main() {
    int x = 10;
    
    if (x > 5) {
        int blockVar = 20; // Block scope
        std::cout << blockVar << std::endl;
    } // blockVar destroyed here
    
    // std::cout << blockVar; // ERROR: not accessible
    
    for (int i = 0; i < 3; i++) {
        int loopVar = i; // Block scope within loop
        std::cout << loopVar << std::endl;
    } // i and loopVar destroyed here
    
    return 0;
}
```

### 4. Class Scope
Members declared inside a class have class scope.

```cpp
#include <iostream>

class MyClass {
private:
    int privateVar = 10; // Class scope - private
    
public:
    int publicVar = 20;  // Class scope - public
    
    void displayVars() {
        std::cout << privateVar << std::endl; // Accessible within class
        std::cout << publicVar << std::endl;
    }
};

int main() {
    MyClass obj;
    obj.displayVars();
    std::cout << obj.publicVar << std::endl; // Public member accessible
    // std::cout << obj.privateVar; // ERROR: private member not accessible
    return 0;
}
```

### 5. Namespace Scope
Variables and functions declared within a namespace have namespace scope.

```cpp
#include <iostream>

namespace MyNamespace {
    int namespaceVar = 100;
    
    void namespaceFunction() {
        std::cout << "Inside namespace" << std::endl;
    }
}

int main() {
    std::cout << MyNamespace::namespaceVar << std::endl;
    MyNamespace::namespaceFunction();
    
    using namespace MyNamespace;
    std::cout << namespaceVar << std::endl; // Direct access after using
    
    return 0;
}
```

## Scope Resolution Operator (::)

```cpp
#include <iostream>

int var = 100; // Global variable

int main() {
    int var = 50; // Local variable
    
    std::cout << var << std::endl;      // Prints 50 (local)
    std::cout << ::var << std::endl;    // Prints 100 (global)
    
    return 0;
}
```

## Variable Shadowing

```cpp
#include <iostream>

int x = 10; // Global

int main() {
    int x = 20; // Shadows global x
    
    {
        int x = 30; // Shadows both global and main's x
        std::cout << x << std::endl; // Prints 30
    }
    
    std::cout << x << std::endl;  // Prints 20
    std::cout << ::x << std::endl; // Prints 10 (global)
    
    return 0;
}
```

## Key Points
- Inner scope variables hide outer scope variables with the same name
- Variables are destroyed when they go out of scope
- Global variables exist for the entire program duration
- Use scope resolution operator `::` to access global variables when shadowed
- Minimize global variables to avoid naming conflicts

## Scope Resolution Operator (::) - Detailed Guide

The scope resolution operator `::` is a powerful tool in C++ that allows you to explicitly specify which scope an identifier belongs to.

### Syntax and Basic Usage

```cpp
::identifier          // Global scope
namespace_name::identifier    // Namespace scope
class_name::identifier       // Class scope (static members)
```

### 1. Accessing Global Variables

When a local variable shadows a global variable:

```cpp
#include <iostream>

int value = 100; // Global variable

void demonstrate() {
    int value = 50; // Local variable shadows global
    
    std::cout << "Local value: " << value << std::endl;     // 50
    std::cout << "Global value: " << ::value << std::endl;  // 100
}
```

### 2. Namespace Resolution

Accessing identifiers from specific namespaces:

```cpp
#include <iostream>

namespace Math {
    const double PI = 3.14159;
    int add(int a, int b) { return a + b; }
}

namespace Physics {
    const double PI = 3.14159265359; // More precise
    double calculateArea(double radius) { return PI * radius * radius; }
}

int main() {
    std::cout << "Math PI: " << Math::PI << std::endl;
    std::cout << "Physics PI: " << Physics::PI << std::endl;
    std::cout << "Sum: " << Math::add(5, 3) << std::endl;
    
    return 0;
}
```

### 3. Class Scope Resolution

Accessing static members and defining functions outside class:

```cpp
#include <iostream>

class Calculator {
public:
    static int count;
    static int multiply(int a, int b);
    void display();
private:
    int value = 10;
};

// Initialize static member
int Calculator::count = 0;

// Define static function outside class
int Calculator::multiply(int a, int b) {
    count++; // Access static member
    return a * b;
}

// Define member function outside class
void Calculator::display() {
    std::cout << "Value: " << value << std::endl;
}

int main() {
    std::cout << Calculator::multiply(4, 5) << std::endl; // Static function
    std::cout << "Function calls: " << Calculator::count << std::endl;
    
    Calculator calc;
    calc.display();
    
    return 0;
}
```

### 4. Nested Namespace Resolution

```cpp
#include <iostream>

namespace Outer {
    int value = 100;
    
    namespace Inner {
        int value = 200;
        
        void showValues() {
            int value = 300; // Local variable
            
            std::cout << "Local: " << value << std::endl;           // 300
            std::cout << "Inner: " << Inner::value << std::endl;    // 200
            std::cout << "Outer: " << Outer::value << std::endl;    // 100
            std::cout << "Global: " << ::value << std::endl;        // Global if exists
        }
    }
}

int value = 50; // Global

int main() {
    Outer::Inner::showValues();
    return 0;
}
```

### 5. Template Specialization

```cpp
#include <iostream>

template<typename T>
class Container {
public:
    void display() { std::cout << "Generic container" << std::endl; }
};

// Template specialization using scope resolution
template<>
void Container<int>::display() {
    std::cout << "Integer container" << std::endl;
}

int main() {
    Container<double> doubleContainer;
    Container<int> intContainer;
    
    doubleContainer.display(); // Generic container
    intContainer.display();    // Integer container
    
    return 0;
}
```

### 6. Enum Class Access

```cpp
#include <iostream>

enum class Color { RED, GREEN, BLUE };
enum class Size { SMALL, MEDIUM, LARGE };

int main() {
    Color c = Color::RED;        // Must use scope resolution
    Size s = Size::LARGE;
    
    // std::cout << RED;         // ERROR: RED not in scope
    std::cout << static_cast<int>(Color::RED) << std::endl;  // Correct
    
    return 0;
}
```

### 7. Avoiding Ambiguity

```cpp
#include <iostream>

namespace A {
    void function() { std::cout << "A::function()" << std::endl; }
}

namespace B {
    void function() { std::cout << "B::function()" << std::endl; }
}

int main() {
    using namespace A;
    using namespace B;
    
    // function();        // ERROR: Ambiguous
    A::function();        // Clear which function to call
    B::function();        // Clear which function to call
    
    return 0;
}
```

### 8. Constructor Initialization Lists

```cpp
#include <iostream>

class Base {
protected:
    int value;
public:
    Base(int v) : value(v) {}
};

class Derived : public Base {
private:
    int value; // Shadows base class member
    
public:
    Derived(int baseVal, int derivedVal) 
        : Base(baseVal), value(derivedVal) {}
    
    void display() {
        std::cout << "Derived value: " << value << std::endl;        // Derived member
        std::cout << "Base value: " << Base::value << std::endl;     // Base member
    }
};
```

### When to Use Scope Resolution Operator

1. **Disambiguating names**: When multiple scopes contain the same identifier
2. **Accessing shadowed variables**: To reach outer scope variables
3. **Static member access**: Calling static functions or accessing static data
4. **Function definitions**: Defining class methods outside the class body
5. **Template specializations**: Specializing templates for specific types
6. **Namespace management**: Avoiding `using` directives while maintaining clarity
7. **Enum class access**: Required for scoped enumerations

### Best Practices

- Use `::` to make code intentions clear
- Prefer explicit scope resolution over `using namespace` in headers
- Use it to avoid naming conflicts in large codebases
- Essential for accessing global scope when local variables shadow globals