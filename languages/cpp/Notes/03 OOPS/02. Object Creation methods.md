# Different Ways to Create Objects in C++

### 1. **Stack Allocation (Automatic Storage)**

Objects are created on the stack and automatically destroyed when they go out of scope.

```cpp
class Student {
private:
    string name;
    int age;
public:
    Student(string n, int a) : name(n), age(a) {}
    void display() { cout << name << " - " << age << endl; }
};

int main() {
    Student s1("Alice", 20);  // Stack allocation
    s1.display();
    // s1 is automatically destroyed when main() ends
    return 0;
}
```

**When to use:**
- Small objects with known lifetime
- Local variables in functions
- When automatic cleanup is desired

### 2. **Heap Allocation (Dynamic Storage) - using `new`**

Objects are created on the heap and must be manually destroyed using `delete`.

```cpp
int main() {
    Student* s2 = new Student("Bob", 22);  // Heap allocation
    s2->display();
    delete s2;  // Must manually delete to avoid memory leak
    s2 = nullptr;  // Good practice
    return 0;
}
```

**When to use:**
- Large objects
- Objects with unknown lifetime
- When you need to return objects from functions
- Dynamic arrays of objects

### 3. **Smart Pointers (Modern C++ - Recommended)**

#### 3a. **unique_ptr** - Single Ownership
```cpp
#include <memory>

int main() {
    std::unique_ptr<Student> s3 = std::make_unique<Student>("Charlie", 21);
    s3->display();
    // Automatically cleaned up when s3 goes out of scope
    return 0;
}
```

#### 3b. **shared_ptr** - Shared Ownership
```cpp
int main() {
    std::shared_ptr<Student> s4 = std::make_shared<Student>("Diana", 23);
    {
        std::shared_ptr<Student> s5 = s4;  // Shared ownership
        s5->display();
    }  // s5 goes out of scope, but object still exists
    s4->display();  // Still valid
    // Object destroyed when last shared_ptr (s4) goes out of scope
    return 0;
}
```

### 4. **Array of Objects**

#### 4a. **Stack Array**
```cpp
int main() {
    Student students[3] = {
        Student("Alice", 20),
        Student("Bob", 22),
        Student("Charlie", 21)
    };
    
    for(int i = 0; i < 3; i++) {
        students[i].display();
    }
    return 0;
}
```

#### 4b. **Dynamic Array**
```cpp
int main() {
    int size = 5;
    Student* students = new Student[size] {
        Student("A", 20), Student("B", 21), Student("C", 22),
        Student("D", 23), Student("E", 24)
    };
    
    for(int i = 0; i < size; i++) {
        students[i].display();
    }
    
    delete[] students;  // Use delete[] for arrays
    return 0;
}
```

### 5. **Vector of Objects (Recommended for Dynamic Arrays)**

```cpp
#include <vector>

int main() {
    std::vector<Student> students;
    
    // Adding objects to vector
    students.emplace_back("Alice", 20);
    students.push_back(Student("Bob", 22));
    
    for(const auto& student : students) {
        student.display();
    }
    // Automatic cleanup when vector goes out of scope
    return 0;
}
```

---

## Comparison of Object Creation Methods

| **Method** | **Memory Location** | **Lifetime** | **Performance** | **Safety** | **Use Case** |
|------------|-------------------|--------------|----------------|------------|--------------|
| Stack Allocation | Stack | Automatic | Fastest | High | Small, local objects |
| new/delete | Heap | Manual | Slower | Low (memory leaks) | Legacy code only |
| unique_ptr | Heap | Automatic | Fast | High | Single ownership |
| shared_ptr | Heap | Reference counted | Moderate | High | Shared ownership |
| Vector | Heap | Automatic | Good | High | Dynamic collections |

---

## Practical Examples and When to Use Each

### 1. **Use Stack Allocation for Local Objects**
```cpp
void processGrades() {
    Student student("John", 20);  // Simple local object
    student.addGrade(85.5);
    cout << "GPA: " << student.calculateGPA() << endl;
    // Automatically destroyed at end of function
}
```

### 2. **Use unique_ptr for Factory Pattern**
```cpp
class AnimalFactory {
public:
    static std::unique_ptr<Animal> createAnimal(string type) {
        if(type == "dog") {
            return std::make_unique<Dog>();
        } else if(type == "cat") {
            return std::make_unique<Cat>();
        }
        return nullptr;
    }
};

int main() {
    auto animal = AnimalFactory::createAnimal("dog");
    if(animal) {
        animal->makeSound();
    }
    return 0;
}
```

### 3. **Use shared_ptr for Shared Resources**
```cpp
class Database {
public:
    void connect() { cout << "Connected to database" << endl; }
    void disconnect() { cout << "Disconnected from database" << endl; }
};

class UserService {
    std::shared_ptr<Database> db;
public:
    UserService(std::shared_ptr<Database> database) : db(database) {}
    void getUser() { db->connect(); /* get user */ }
};

class OrderService {
    std::shared_ptr<Database> db;
public:
    OrderService(std::shared_ptr<Database> database) : db(database) {}
    void getOrder() { db->connect(); /* get order */ }
};

int main() {
    auto database = std::make_shared<Database>();
    
    UserService userSvc(database);
    OrderService orderSvc(database);  // Shared database connection
    
    userSvc.getUser();
    orderSvc.getOrder();
    
    return 0;
}
```

### 4. **Use Vector for Dynamic Collections**
```cpp
class StudentManager {
private:
    std::vector<Student> students;
    
public:
    void addStudent(const string& name, int age) {
        students.emplace_back(name, age);
    }
    
    void displayAllStudents() {
        for(const auto& student : students) {
            student.display();
        }
    }
    
    size_t getCount() const {
        return students.size();
    }
};
```

---

## Best Practices for Object Creation

1. **Prefer stack allocation** for small, local objects
2. **Use smart pointers** instead of raw `new/delete`
3. **Use `make_unique`** and `make_shared`** for exception safety
4. **Use `std::vector`** instead of dynamic arrays
5. **Avoid raw pointers** for ownership
6. **Use RAII** (Resource Acquisition Is Initialization) principle

**Remember:** Modern C++ favors automatic memory management over manual memory management!
