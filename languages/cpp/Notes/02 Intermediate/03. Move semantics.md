# Move Semantics in C++

## What are Move Semantics?

Move semantics is a C++11 feature that allows resources to be transferred from one object to another without copying. Instead of creating expensive copies, move semantics "moves" the ownership of resources, making operations more efficient.

## Key Concepts

### Rvalue References
- Declared with `&&` (double ampersand)
- Bind to temporary objects and objects being moved
- Enable move semantics implementation

```cpp
int&& rref = 10;  // rvalue reference to temporary
std::string&& str_ref = std::string("hello");
```

### Move Constructor
- Takes an rvalue reference parameter
- Transfers resources from source to destination
- Leaves source in valid but unspecified state

```cpp
class MyClass {
private:
    int* data;
    size_t size;

public:
    // Move constructor
    MyClass(MyClass&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
};
```

### Move Assignment Operator
- Assigns resources from rvalue to existing object
- Should handle self-assignment
- Should be marked `noexcept`

```cpp
MyClass& operator=(MyClass&& other) noexcept {
    if (this != &other) {
        delete[] data;  // Clean up existing resources
        data = other.data;
        size = other.size;
        other.data = nullptr;
        other.size = 0;
    }
    return *this;
}
```

## When to Use Move Semantics

### 1. Resource Management Classes
- Classes managing dynamic memory
- File handles, network connections
- Smart pointers

### 2. Container Operations
- Returning large objects from functions
- Inserting objects into containers
- Swapping operations

### 3. Performance Critical Code
- When copying is expensive
- Large data structures
- Frequent object transfers

## How to Use Move Semantics

### std::move()
- Casts lvalue to rvalue reference
- Enables move operations on named objects

```cpp
std::vector<int> v1 = {1, 2, 3, 4, 5};
std::vector<int> v2 = std::move(v1);  // v1 is now empty
```

### Perfect Forwarding
- Used in template functions
- Preserves value category of arguments

```cpp
template<typename T>
void wrapper(T&& arg) {
    function(std::forward<T>(arg));
}
```

### Return Value Optimization (RVO)
- Compiler automatically moves when returning objects
- No need for explicit std::move in return statements

```cpp
std::vector<int> create_vector() {
    std::vector<int> v = {1, 2, 3};
    return v;  // Automatically moved, don't use std::move here
}
```

## Where Move Semantics are Useful

### 1. Standard Library Containers
```cpp
std::vector<std::string> vec;
std::string str = "hello world";
vec.push_back(std::move(str));  // Moves instead of copying
```

### 2. Function Parameter Passing
```cpp
void process_data(std::vector<int> data) {  // Pass by value for move
    // Function takes ownership of data
}

std::vector<int> large_vector = get_data();
process_data(std::move(large_vector));  // Efficient transfer
```

### 3. Object Factories
```cpp
std::unique_ptr<Object> create_object() {
    auto obj = std::make_unique<Object>();
    // Configure object...
    return obj;  // Automatically moved
}
```

## Best Practices

### 1. Rule of Five/Zero
- If you implement move constructor, also implement move assignment
- Consider if you need custom copy operations
- Prefer Rule of Zero when possible

### 2. noexcept Specification
- Always mark move operations as `noexcept` when safe
- Enables optimizations in standard containers

```cpp
MyClass(MyClass&& other) noexcept;
MyClass& operator=(MyClass&& other) noexcept;
```

### 3. Don't Move from const Objects
```cpp
const std::string str = "hello";
auto str2 = std::move(str);  // This copies, doesn't move!
```

### 4. Avoid std::move on Return Values
```cpp
// Don't do this
std::vector<int> bad_function() {
    std::vector<int> v = {1, 2, 3};
    return std::move(v);  // Prevents RVO
}

// Do this instead
std::vector<int> good_function() {
    std::vector<int> v = {1, 2, 3};
    return v;  // Enables RVO/move
}
```

## Common Pitfalls

### 1. Moving from Objects You Still Need
```cpp
std::string str = "hello";
auto str2 = std::move(str);
std::cout << str;  // str is in unspecified state!
```

### 2. Not Checking for Self-Assignment
```cpp
MyClass& operator=(MyClass&& other) noexcept {
    // Always check for self-assignment
    if (this == &other) return *this;
    // ... rest of implementation
}
```

### 3. Forgetting to Reset Moved-from State
```cpp
MyClass(MyClass&& other) noexcept {
    data = other.data;
    // Must reset other's state
    other.data = nullptr;  // Important!
}
``` 