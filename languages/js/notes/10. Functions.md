# Functions in JavaScript

Functions are reusable blocks of code designed to perform a specific task. They are one of the fundamental building blocks in JavaScript.

## Basic Function Syntax

### Function Declaration

```javascript
function functionName(parameter1, parameter2) {
    // code to be executed
    return value; // optional
}
```

Example:
```javascript
function add(a, b) {
    return a + b;
}

console.log(add(5, 3)); // 8
```

### Function Expression

Assigns a function to a variable.

```javascript
const functionName = function(parameter1, parameter2) {
    // code to be executed
    return value; // optional
};
```

Example:
```javascript
const multiply = function(a, b) {
    return a * b;
};

console.log(multiply(4, 2)); // 8
```

### Arrow Functions (ES6)

A shorter syntax for writing functions.

```javascript
const functionName = (parameter1, parameter2) => {
    // code to be executed
    return value; // optional
};
```

Example:
```javascript
const divide = (a, b) => {
    return a / b;
};

// Shorter syntax for single-line functions
const square = x => x * x;

console.log(divide(8, 2)); // 4
console.log(square(5)); // 25
```

### IIFE (Immediately Invoked Function Expression)

Functions that run as soon as they are defined.

```javascript
(function() {
    // code to be executed immediately
})();
```

Example:
```javascript
(function() {
    console.log("This function runs immediately!");
})();
```

## First-Class Functions

In JavaScript, functions are **first-class citizens** (or first-class objects). This means:

- Functions can be assigned to variables.
- Functions can be passed as arguments to other functions.
- Functions can be returned from other functions.
- Functions can have properties and methods.

This allows for powerful programming patterns such as callbacks, higher-order functions, and functional programming.

**Example: Passing a function as an argument**
```javascript
function greet(name) {
    return `Hello, ${name}!`;
}

function processUserInput(callback) {
    const name = "Alice";
    console.log(callback(name));
}

processUserInput(greet); // "Hello, Alice!"
```

**Example: Returning a function from another function**
```javascript
function multiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplier(2);
console.log(double(5)); // 10
```

**Example: Assigning a function to a variable**
```javascript
const sayHi = function() {
    console.log("Hi!");
};

sayHi(); // "Hi!"
```

**Example: Storing functions in an array**
```javascript
const operations = [
    x => x + 1,
    x => x * 2,
    x => x * x
];

console.log(operations[0](5)); // 6
console.log(operations[1](5)); // 10
console.log(operations[2](5)); // 25
```

**Example: Adding properties to a function**
```javascript
function counter() {
    counter.count = (counter.count || 0) + 1;
    return counter.count;
}

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter.count); // 2
```

## Function Parameters

### Default Parameters (ES6)

```javascript
function greet(name = "Guest") {
    return `Hello, ${name}!`;
}

console.log(greet()); // "Hello, Guest!"
console.log(greet("John")); // "Hello, John!"
```

### Rest Parameters (ES6)

```javascript
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

### Difference Between Function Parameters and Function Arguments

- **Parameters** are the names listed in the function definition. They act as placeholders for the values that will be passed to the function.
- **Arguments** are the actual values supplied to the function when it is invoked.

**Example:**
```javascript
function add(a, b) { // a and b are parameters
    return a + b;
}

add(2, 3); // 2 and 3 are arguments
```

## Function Properties

### Function Hoisting

Function declarations are hoisted, allowing them to be called before they're defined.

```javascript
// This works
sayHello(); 

function sayHello() {
    console.log("Hello!");
}

// This doesn't work
// sayHi(); // Error

const sayHi = function() {
    console.log("Hi!");
};
```

### Function as Object

Functions are objects and can have properties.

```javascript
function counter() {
    counter.count = counter.count || 0;
    counter.count++;
    return counter.count;
}

console.log(counter()); // 1
console.log(counter()); // 2
```

### Function length Property

The length property indicates the number of parameters expected by the function.

```javascript
function func1(a) {}
function func2(a, b) {}
function func3(a, b, c) {}

console.log(func1.length); // 1
console.log(func2.length); // 2
console.log(func3.length); // 3
```

### Function name Property

The name property returns the function's name.

```javascript
function test() {}
console.log(test.name); // "test"

const anonymous = function() {};
console.log(anonymous.name); // "anonymous"

const arrow = () => {};
console.log(arrow.name); // "arrow"
```
## Difference Between Conventional Functions and Arrow Functions

| Feature                | Conventional Functions                | Arrow Functions                       |
|------------------------|---------------------------------------|---------------------------------------|
| **Syntax**             | `function add(a, b) { return a + b; }`| `const add = (a, b) => a + b;`        |
| **`this` Binding**     | Has its own `this` (dynamic binding)  | Inherits `this` from enclosing scope (lexical binding) |
| **`arguments` Object** | Has access to `arguments` object      | Does **not** have its own `arguments` object |
| **Constructor**        | Can be used as constructors with `new`| Cannot be used as constructors        |
| **Methods**            | Suitable for object methods           | Not suitable for defining object methods (due to `this` binding) |
| **Hoisting**           | Function declarations are hoisted     | Arrow functions are not hoisted       |


**Example: Syntax**
```javascript
// Conventional function
function add(a, b) {
    return a + b;
}

// Arrow function
const addArrow = (a, b) => a + b;

console.log(add(2, 3));      // 5
console.log(addArrow(2, 3)); // 5
```

**Example: `this` behavior**
```javascript
const obj = {
    value: 42,
    regular: function() { return this.value; },
    arrow: () => this.value
};

console.log(obj.regular()); // 42
console.log(obj.arrow());   // undefined (or window.value in browsers)
```

**Example: `arguments` object**
```javascript
function showArgs() {
    return arguments;
}

const showArgsArrow = () => {
    // arguments is not defined here
    // return arguments; // This would throw a ReferenceError
    return "Arrow functions do not have their own arguments object";
};

console.log(showArgs(1, 2, 3));         // [Arguments] { '0': 1, '1': 2, '2': 3 }
console.log(showArgsArrow(1, 2, 3));    // "Arrow functions do not have their own arguments object"
```

**Example: Constructor usage**
```javascript
function Person(name) {
    this.name = name;
}
const person1 = new Person("Alice");
console.log(person1.name); // "Alice"

// Arrow functions cannot be used as constructors
const PersonArrow = (name) => {
    this.name = name;
};
// const person2 = new PersonArrow("Bob"); // TypeError: PersonArrow is not a constructor
```

**Example: Methods in objects**
```javascript
const obj1 = {
    value: 10,
    method: function() {
        return this.value;
    }
};

const obj2 = {
    value: 20,
    method: () => {
        return this.value;
    }
};

console.log(obj1.method()); // 10
console.log(obj2.method()); // undefined (or window.value in browsers)
```

**Example: Hoisting**
```javascript
hoisted(); // "I'm hoisted!"

function hoisted() {
    console.log("I'm hoisted!");
}

// notHoisted(); // ReferenceError: Cannot access 'notHoisted' before initialization
const notHoisted = () => {
    console.log("I'm not hoisted!");
};
```

**Summary:**  
Use conventional functions when you need your own `this`, `arguments`, or to create constructors. Use arrow functions for concise syntax and when you want to inherit `this` from the surrounding context.
