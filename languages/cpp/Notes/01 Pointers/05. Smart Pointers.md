# Smart Pointers

## What are Smart Pointers?

Smart pointers are objects that act like traditional pointers but provide automatic memory management. They are template classes that wrap raw pointers and automatically handle memory allocation and deallocation.

## Differences from Raw Pointers

| Raw Pointers | Smart Pointers |
|--------------|----------------|
| Manual memory management | Automatic memory management |
| No ownership semantics | Clear ownership semantics |
| Prone to memory leaks | Prevent memory leaks |
| No automatic cleanup | Automatic cleanup via RAII |
| Can lead to dangling pointers | Safer pointer operations |

## Types of Smart Pointers (C++11 and later)

### 1. `std::unique_ptr`
- **Ownership**: Exclusive ownership
- **Copying**: Cannot be copied, only moved
- **Use case**: Single owner scenarios

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(42);
```

### 2. `std::shared_ptr`
- **Ownership**: Shared ownership
- **Reference counting**: Uses reference counting
- **Use case**: Multiple owners scenarios

```cpp
std::shared_ptr<int> ptr = std::make_shared<int>(42);
```

### 3. `std::weak_ptr`
- **Ownership**: Non-owning observer
- **Purpose**: Breaks circular references
- **Use case**: Used with `shared_ptr` to avoid cycles

```cpp
std::weak_ptr<int> weak_ptr = shared_ptr_instance;
```

## Key Benefits

- **RAII (Resource Acquisition Is Initialization)**: Automatic resource management
- **Exception Safety**: Resources cleaned up even during exceptions
- **Memory Leak Prevention**: Automatic deallocation
- **Clear Ownership Semantics**: Explicit ownership relationships

## Detailed Guide to Smart Pointers

### `std::unique_ptr` - Exclusive Ownership

#### How to Use
```cpp
#include <memory>

// Creation
std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
std::unique_ptr<int> ptr2(new int(20)); // Less preferred

// Access
*ptr1 = 15;
int value = *ptr1;

// Transfer ownership (move semantics)
std::unique_ptr<int> ptr3 = std::move(ptr1); // ptr1 is now null

// Release ownership
int* raw_ptr = ptr1.release(); // Returns raw pointer, ptr1 becomes null
delete raw_ptr; // Manual cleanup required

// Reset
ptr1.reset(new int(30)); // Deletes old object, assigns new one
ptr1.reset(); // Deletes object, sets to null
```

#### When to Use - Examples

**1. Function Parameters (Pass by reference or move)**
```cpp
// Pass by reference for read-only access
void processData(const std::unique_ptr<Database>& db) {
    db->query("SELECT * FROM users");
}

// Move for transfer of ownership
std::unique_ptr<FileHandler> createFileHandler(std::unique_ptr<Logger> logger) {
    return std::make_unique<FileHandler>(std::move(logger));
}
```

**2. Factory Functions**
```cpp
class Image {
public:
    static std::unique_ptr<Image> loadFromFile(const std::string& filename) {
        auto img = std::make_unique<Image>();
        // Load image data...
        return img;
    }
};

// Usage
auto image = Image::loadFromFile("photo.jpg");
```

**3. PIMPL (Pointer to Implementation) Idiom**
```cpp
// Header file
class NetworkManager {
private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
public:
    NetworkManager();
    ~NetworkManager(); // Required for PIMPL with unique_ptr
    void connect();
};

// Implementation file
class NetworkManager::Impl {
    // Complex implementation details hidden
};
```

**4. Resource Management**
```cpp
class TextureManager {
    std::unique_ptr<unsigned char[]> pixels;
public:
    TextureManager(int width, int height) 
        : pixels(std::make_unique<unsigned char[]>(width * height * 4)) {
        // Automatic cleanup when object is destroyed
    }
};
```

### `std::shared_ptr` - Shared Ownership

#### How to Use
```cpp
#include <memory>

// Creation
std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
std::shared_ptr<int> ptr2(new int(50)); // Less efficient

// Copying (increases reference count)
std::shared_ptr<int> ptr3 = ptr1; // Reference count: 2

// Check reference count
std::cout << ptr1.use_count() << std::endl; // Prints: 2

// Access
*ptr1 = 100;
int value = *ptr3; // value = 100

// Custom deleter
std::shared_ptr<int> ptr4(new int(60), [](int* p) {
    std::cout << "Custom delete" << std::endl;
    delete p;
});
```

#### When to Use - Examples

**1. Containers Storing Pointers to Shared Objects**
```cpp
class Document {
    std::string content;
public:
    Document(const std::string& text) : content(text) {}
    void display() const { std::cout << content << std::endl; }
};

class DocumentManager {
    std::vector<std::shared_ptr<Document>> documents;
    std::shared_ptr<Document> activeDoc;
public:
    void addDocument(const std::string& content) {
        auto doc = std::make_shared<Document>(content);
        documents.push_back(doc);
        activeDoc = doc; // Both container and activeDoc share ownership
    }
};
```

**2. Callback Systems**
```cpp
class EventHandler {
public:
    virtual ~EventHandler() = default;
    virtual void handle() = 0;
};

class EventManager {
    std::vector<std::shared_ptr<EventHandler>> handlers;
public:
    void registerHandler(std::shared_ptr<EventHandler> handler) {
        handlers.push_back(handler);
    }
    
    void triggerEvent() {
        for (auto& handler : handlers) {
            if (handler) { // Check if still valid
                handler->handle();
            }
        }
    }
};
```

**3. Thread-Safe Sharing**
```cpp
class Logger {
    std::mutex mtx;
public:
    void log(const std::string& message) {
        std::lock_guard<std::mutex> lock(mtx);
        std::cout << "[LOG] " << message << std::endl;
    }
};

// Multiple threads can safely share the logger
std::shared_ptr<Logger> globalLogger = std::make_shared<Logger>();

void workerThread(std::shared_ptr<Logger> logger) {
    logger->log("Worker thread started");
    // Logger automatically cleaned up when last reference goes away
}
```

**4. Cache Implementation**
```cpp
class ExpensiveResource {
    std::string data;
public:
    ExpensiveResource(const std::string& key) {
        // Simulate expensive computation
        data = "Computed data for " + key;
    }
    const std::string& getData() const { return data; }
};

class ResourceCache {
    std::map<std::string, std::shared_ptr<ExpensiveResource>> cache;
public:
    std::shared_ptr<ExpensiveResource> getResource(const std::string& key) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            return it->second; // Return shared resource
        }
        
        auto resource = std::make_shared<ExpensiveResource>(key);
        cache[key] = resource;
        return resource;
    }
};
```

### `std::weak_ptr` - Non-owning Observer

#### How to Use
```cpp
#include <memory>

std::shared_ptr<int> shared = std::make_shared<int>(100);
std::weak_ptr<int> weak = shared;

// Check if object still exists
if (!weak.expired()) {
    // Lock to get shared_ptr
    if (auto locked = weak.lock()) {
        std::cout << *locked << std::endl; // Safe access
    }
}

// Check reference count (doesn't include weak_ptr count)
std::cout << weak.use_count() << std::endl;
```

#### When to Use - Examples

**1. Breaking Circular References**
```cpp
class Parent {
    std::vector<std::shared_ptr<Child>> children;
public:
    void addChild(std::shared_ptr<Child> child) {
        children.push_back(child);
        child->setParent(shared_from_this());
    }
};

class Child : public std::enable_shared_from_this<Child> {
    std::weak_ptr<Parent> parent; // Breaks circular reference
public:
    void setParent(std::shared_ptr<Parent> p) {
        parent = p;
    }
    
    void notifyParent() {
        if (auto p = parent.lock()) {
            // Safely access parent
            std::cout << "Parent is still alive" << std::endl;
        }
    }
};
```

**2. Observer Pattern**
```cpp
class Subject {
    std::vector<std::weak_ptr<Observer>> observers;
public:
    void addObserver(std::shared_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    
    void notifyObservers() {
        // Remove expired observers while iterating
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<Observer>& weak) {
                    return weak.expired();
                }),
            observers.end()
        );
        
        // Notify remaining observers
        for (auto& weak_obs : observers) {
            if (auto obs = weak_obs.lock()) {
                obs->update();
            }
        }
    }
};
```

**3. Cache with Automatic Cleanup**
```cpp
class ImageCache {
    std::map<std::string, std::weak_ptr<Image>> cache;
public:
    std::shared_ptr<Image> getImage(const std::string& filename) {
        // Check if image is still in memory
        auto it = cache.find(filename);
        if (it != cache.end()) {
            if (auto img = it->second.lock()) {
                return img; // Return existing image
            }
            // Image was destroyed, remove from cache
            cache.erase(it);
        }
        
        // Load new image
        auto img = std::make_shared<Image>(filename);
        cache[filename] = img; // Store weak reference
        return img;
    }
};
```

**4. Back-Reference in Tree Structures**
```cpp
class TreeNode : public std::enable_shared_from_this<TreeNode> {
    std::weak_ptr<TreeNode> parent;
    std::vector<std::shared_ptr<TreeNode>> children;
    std::string data;
    
public:
    TreeNode(const std::string& value) : data(value) {}
    
    void addChild(const std::string& value) {
        auto child = std::make_shared<TreeNode>(value);
        child->parent = shared_from_this(); // Weak reference to parent
        children.push_back(child);
    }
    
    std::shared_ptr<TreeNode> getParent() {
        return parent.lock(); // Safely get parent if it exists
    }
};
```

## Key Differences Summary

| Feature | `unique_ptr` | `shared_ptr` | `weak_ptr` |
|---------|-------------|-------------|------------|
| **Ownership** | Exclusive | Shared | Non-owning |
| **Copyable** | No (move-only) | Yes | Yes |
| **Reference Counting** | No | Yes | No (observes shared_ptr) |
| **Memory Overhead** | Minimal | Higher (control block) | Minimal |
| **Thread Safety** | No | Reference counting only | Reference counting only |
| **Null Check** | `if (ptr)` | `if (ptr)` | `if (!weak.expired())` |
| **Access** | `*ptr`, `ptr->` | `*ptr`, `ptr->` | Must lock first |

## Best Practices

### Performance Considerations
- Prefer `make_unique` and `make_shared` over `new`
- `unique_ptr` has zero overhead compared to raw pointers
- `shared_ptr` has overhead due to reference counting
- Avoid cyclic dependencies with `shared_ptr`

### Common Patterns
```cpp
// Factory function
std::unique_ptr<Widget> createWidget() {
    return std::make_unique<Widget>();
}

// Shared resource
class Cache {
    std::shared_ptr<Data> cached_data;
public:
    std::shared_ptr<Data> getData() { return cached_data; }
};

// Breaking cycles
class Parent {
    std::vector<std::shared_ptr<Child>> children;
};

class Child {
    std::weak_ptr<Parent> parent; // Avoids cycle
};
```